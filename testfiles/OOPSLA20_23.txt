95
解　説
プログラム合成技術の動向調査
倉林利行　丹野治門　切貫弘之　大島剛志
仕様情報からプログラムを自動生成するプログラム合成技術に関する調査を行った．ソフトウェア工学，プログラミ
ング言語，人工知能分野，自然言語処理分野における主要会議の2016 年から2020 年までのフルペーパーの論文を
対象とし，手法や適用ドメイン等で分類した．本論文を読むことで，最近5 年間のプログラム合成技術の動向につい
て，俯瞰的に知ることができる．
We conducted a survey on program synthesis techniques that automatically generate programs from speciﬁ-
cation information. Full papers from 2016 to 2020 of major conferences in the ﬁelds of software engineering,
programming languages, artiﬁcial intelligence and natural language processing were covered and catego-
rized by methods and application domains. This paper provides a bird’s eye view of the trends in program
synthesis techniques in the last ﬁve years.
1
はじめに
プログラミングはかつて高い専門性が求められる
スキルであり，研究者やプログラマなど，一部の人に
しか馴染みがなかった．しかし近年，急速なスマート
デバイスの普及によって個人でもアプリケーション
等を開発する人は増えており，また特に日本ではプロ
グラミングの義務教育化†1 もあり，多くの人にプロ
グラミングが広まろうとしている．特にプログラミ
ングの義務教育化によって小学生からプログラミン
グに親しむ世代は，日々の業務の効率化や分析のため
にプログラムを書こうとするなど，プログラミングが
身近な存在になるだろう．よってプログラミングの
効率化は，ソフトウェア開発だけでなく多くの産業の
効率化に繫がる可能性がある．
A Survey of Program Synthesis.
Toshiyuki Kurabayashi, Haruto Tanno, Hiroyuki Kir-
inuki, Tsuyoshi Oshima, 日本電信電話株式会社ソ
フトウェアイノベーションセンタ, Software In-
novation Center, Nippon Telegraph and Telephone
Corporation.
コンピュータソフトウェア,Vol.40, No.2 (2023),pp.95–128.
[解説論文] 2021 年11 月9 日受付.
プログラム合成は，現在のプログラミングを抜本的
に変革する可能性のある技術である．プログラム合成
では，図1 のように，ユーザが与えた仕様情報からプ
ログラムを自動生成する．仕様は形式的に定められた
厳密かつ詳細な情報である必要はなく，入出力例や自
然言語など，曖昧な仕様情報からもプログラムを自動
生成できることが特徴である．よってプログラマだけ
でなく一般的なユーザにとっても馴染みやすい技術で
あり，実際にExcel のFlashFill [45] 等に導入されて
いる．FlashFill では，Excel に入力された文字列の規
則性をプログラム合成によって見つけ，繰り返しとな
る作業を自動化する．図2 はExcel においてメール
アドレスから苗字を抜き出す時に，実際にFlashFill
を使用した例である．メールアドレスは「名前. 苗字.
英字2 文字@example.com」から構成されており，苗
字部分のみ取り出したいとする．普段Excel を使用
している人でも，Excel の関数を使って苗字のみを抜
き出すプログラムを瞬時に書ける人は少ないだろう．
しかしFlashFill では，少数の入出力例を示すだけで
この作業を瞬時に自動で行うことができる．図2 のよ
†1
https://www.mext.go.jp/a menu/shotou/
zyouhou/
96
コンピュータソフトウェア
うに，「taro.yamada.ab@example.com」というメー
ルアドレスに対して「yamada」という抽出例を用意
する．この状態で赤い枠で囲われた「フラッシュフィ
ル」ボタンをクリックすることで，以降の苗字の抽出
をすべて自動で行うことができる．これは，Excel の
内部で，与えられた入力例から出力例への変換を行う
ようなプログラムを自動生成しているためであり，プ
ログラム合成が生産性を向上させる実例である．
最近では深層学習技術の発展により，深層学習を用
いたプログラム合成の研究も行われている．例えば
GitHub Copilot†2 ではGitHub 上のプログラムを大
規模な深層学習モデルで学習することで，メソッド名
やコメントからメソッドの中身の自動生成を可能に
している．
本論文では，最近5 年間のプログラム合成技術に
ついて，動向調査を行った結果を報告する．本論文の
貢献は以下の通りである．
• ソフトウェア工学，プログラミング言語，人工
知能分野，自然言語処理分野における主要会議
の2016 年から2020 年までのフルペーパーの論
文を対象にプログラム合成技術について網羅的
に調査を行うことで，これまで異なる分野に点在
していたプログラム合成の研究を整理した．
• 調査論文は，仕様の定義方法，プログラム空間
の定義方法，プログラム空間の探索方法，技術の
適用ドメインの4 つの観点で分類を行い，さら
に各観点において詳細な分類を行った．
• 各分類における論文数の年ごとの推移を統計的
なデータとしてまとめた．
• 本論文を読むことで，これまで整理されていな
かった最近5 年間のプログラム合成技術の動向
について，俯瞰的に知ることができる．
以下，2 章で調査方法の詳細について説明し，3 章で
2015 年以前のプログラム合成技術の概要を紹介し，
4 章から7 章で調査結果を紹介し，8 章で考察を述べ
る．最後に9 章で本論文のまとめを述べる．
†2
https://copilot.github.com/
図1
プログラム合成
図2
FlashFill による苗字の抽出
2
調査方法
2. 1
調査対象
プログラムは関数，変数，定数などの基本的な要素
(本論文ではコンポーネントと呼ぶ) から構成される．
コンポーネントを組み合わせることで無数の種類の
プログラムを作成できる．プログラム合成はそのよ
うな無数のプログラムの中から，図1 のように仕様
情報を満たすコンポーネントの組み合わせ(つまりプ
Vol. 40
No. 2
May 2023
97
ログラム) を探し出す技術である．決められたルール
に則って仕様からプログラムへ変換するのではなく，
仕様を満たすプログラムを何らかの探索を行うこと
で探し出すことが特徴である[48]．本論文ではプログ
ラム合成技術に関する論文を調査の対象とする．た
だし，プログラム合成技術を活用していたとしても
別の分野として確立されている研究は対象外とする．
具体的には以下のような研究である．
• コード補完に関する研究(仕様からプログラムを
生成していないため).
• コンパイルに関する研究(決められたルールに
則って変換しているため).
• 詳細なモデル等をプログラムへ変換する，モデ
ルベースのプログラム生成に関する研究(決めら
れたルールに則って変換しているため).
• バグ自動修正に関する研究(別の研究分野として
確立しているため[43]).
• リファクタリングや最適化等の，既存のプログ
ラムの振る舞いを変えずに別のプログラムに変
換する研究(別の研究分野として確立しているた
め[83]).
• Reactive Synthesis [14] やInvariant Synthesis
[11] 等のプログラム合成に関連した技術を用いな
がらも，生成物がプログラムではない研究.
2. 2
調査方法
本論文では以下の手順で調査を行った．
1. 情報処理分野の論文情報が掲載されてい
るDBLP†3(Digital Bibliographic Library &
Project) のサイトから，ソフトウェア工学，プロ
グラミング言語，人工知能分野，自然言語処理分
野における主要会議の2016 年から2020 年まで
のフルペーパー論文の「題目，概要，キーワード」
を全て収集した．主要な会議とは2021 年10 月時
点においてConference Portal - Core†4 の2020
年のランクでA ＊となっている会議であり，具体
的にはソフトウェア工学分野はICSE，FSE，プ
ログラミング言語分野はASPLOS，OOPSLA，
†3
https://dblp.org/
†4
http://portal.core.edu.au/conf-ranks/
PLDI，POPL，CAV，ICFP，TACAS，人工知能
分野はICML，NeurIPS，AAAI，IJCAI，ICLR，
COLT，自然言語処理分野はACL の計16 個の
会議を対象としている．ただしTACAS はA ラ
ンクであるが，EUSolver [4] 等の著名なプログ
ラム合成技術が発表されていたため，調査対象
に含めた．また人工知能分野の会議は論文の投
稿数が多く，フルペーパーの論文であってもポ
スター発表になる場合がある．例えば2018 年の
NeurIPS の参加報告[40] によると，投稿された
4854 本のうち1010 本が採択されており，採択
率は約21%であるが，その1010 本の中でも口頭
発表は30 本，スポットライト発表は168 本であ
り，それ以外はすべてポスター発表となってい
る．そのため人工知能分野においては，ポスター
発表となった論文についても十分に競合的な研
究であると考え，調査対象に含めた．
2. 手順1 で抽出した論文について，「題目，概要，
キーワード」のいずれかに“program synthesis”，
“automatic programming”，“code generation”
等のプログラム合成技術に関連する語句を含む
論文を抽出．
3. 手順2 で抽出した論文について，著者らで論文
内容の確認を行い，2. 1 節で定めた調査対象と
合致すると判断した論文を抽出し，調査対象と
する．
手順2 では255 件が検出され，手順3 で最終的に122
件に絞り込まれた．
2. 3
分類方法
Gulwani らは，プログラム合成はユーザの意図の
伝え方，プログラムの探索空間，プログラムの探索技
術の3 つの観点で分類できると述べている[48]．本論
文ではそれらの観点に加え，プログラム合成技術の適
用ドメインで分類を行った．つまり本論文での分類
観点は以下のようになる．
• ユーザの意図をどのような形式で与えるか？
• プログラム空間をどう定義するか？
• プログラム空間をどう探索するか？
• プログラム合成をどのドメインに適用するか？
98
コンピュータソフトウェア
以下では，各分類観点における最新の論文の動向を把
握する上で必要な前提知識について説明する．
2. 3. 1
調査1：ユーザの意図をどのような形式で
与えるか？
プログラム合成ではユーザの意図をシステムに伝
えるために，プログラムの仕様として何らかの形式で
表現する必要がある．例えば入出力例は仕様を表す
ことができる形式のうちの1 つであり，図1 で表さ
れるユーザの意図の場合，[3, 6, 4, 5] →[1, 2] (ただし
[3, 6, 4, 5] は入力となるリスト，[1, 2] は出力となるリ
ストを表す) などが挙げられる．
ある形式がプログラム合成において適切であるか
どうかは，ユーザ側とシステム側，両方の側面から評
価するべきである．もし仕様の作成に多くのユーザ
の工数を必要とする，もしくは高いスキルが求められ
る場合は，ユーザにとって使いにくい技術になってし
まう恐れがある．また仕様がシステムにとって解釈
が困難であったり，情報量が少ない場合は，ユーザが
所望するプログラムと異なるプログラムが生成され
てしまう．例えば入出力例はユーザにとって作成し
やすくシステムにとっても解釈は容易だが，ユーザの
意図のごく一部しか表せないため情報量が少ないと
いう欠点がある．すべての観点において優れた形式
は存在しないため，使用するシチュエーションに応じ
て適切な形式を用いることが重要である．
2. 3. 2
調査2：プログラム空間をどう定義するか？
コンポーネントの組み合わせで表されるプログラ
ムの集合をプログラム空間と呼ぶ．プログラム合成
ではプログラム空間の中から仕様に合うプログラム
を探し出さなくてはならない．しかしM 種類のコン
ポーネントが存在する時，N 個のコンポーネントで
構成されるプログラムのパターンはM N 通りである．
つまりコンポーネントの種類に応じてプログラム空
間が指数関数的に増加し，所望のプログラムの発見が
困難になる．
そこで探索空間を狭めるために，適用ドメインに応
じてドメイン固有言語(Domain-Speciﬁc Language，
以下DSL) を設計する方法が存在する．DSL の一例
を図3 に示す．ただしλx:process はラムダ式を表
し，引数をx としてprocess に記述された処理を実
list, 開始記号L
::=
ARG | sort(L) |
filter(Fb,L) |
map(Fi,L)
bool を返す関数Fb
::=
λx:x>I | λx:x<I
λx:x==I
int を返す関数Fi
::=
λx:x+I | λx:x-I
λx:x*I
int I
::=
0 | 1 | 2 | 3 | 4
図3
文脈自由文法で表されたDSL の一例．ただし
ARG は入力となるリストを示す．
行する．DSL ではコンポーネントを種類で分け，ど
の種類のコンポーネントと組み合わされるかを指定す
る．例えばfilter(Fb,L) は第一引数にbool を返す
関数が，第二引数にlist が入ることを意味する．また
filter(Fb,L) のように他のコンポーネントで置換さ
れる記号を持つコンポーネントを非終端記号，ARG の
ように置換される記号を持たないコンポーネントを
終端記号と呼ぶ．またコンポーネントを組み合わせ
る時，一番先頭に使用されるコンポーネント(例えば
filter(Fb,L) の場合，Fb とL にどのようなコンポー
ネントを入れてもfilter が先頭になる) を開始記号
と呼ぶ．これらのコンポーネントを開始記号から組
み合わせることで，プログラムを作成する．図3 は
様々なリスト操作を表現できるDSL である．より探
索空間を絞りこむためには，なるべく少ないコンポー
ネントで特定ドメインを表現できるDSL を設計する
ことが重要である．
2. 3. 3
調査3：プログラム空間をどう探索するか？
前項では，DSL によるプログラム空間の絞り込み
が重要であると述べた．しかし現実にはDSL を用い
てもなお，プログラム空間の探索は膨大な時間がかか
る．探索の難しさについて，プログラム合成の最も基
本的な探索手法である列挙探索を用いて説明する．
列挙探索にはDSL において終端記号のみで表現さ
れるプログラムをサイズが小さいものから列挙して
いくボトムアップ探索と，非終端記号を含む不完全
なプログラムも含めて列挙していくトップダウン探
索が存在する(終端記号と非終端記号の定義は2. 3. 2
項参照)．ここでは図1 でユーザが求めているプロ
Vol. 40
No. 2
May 2023
99
仕様(入出力例)：[3,6,4,5] →[1,2]
開始記号(1 個)
L
1 探索目(4 個)
ARG sort(L) filter(Fb,L) map(Fi,L)
2 探索目(18 個)
sort(ARG) sort(sort(L)) sort(filter(Fb,L)) map(Fi,ARG)
filter(λx:x>I,L) filter(λx:x<I,L) filter(λx:x==I,L) ..
3 探索目(132 個)
.. sort(filter(Fb,map(Fi,L))) ..
4 探索目(1104 個)
.. sort(filter(λx:x>I,map(Fi,L))) ..
:
8 探索目(約810 万個)
.. sort(filter(λx:x>0,map(λx:x-4,ARG))) ←仕様を満たすプログラム
図4
トップダウン探索によるプログラム合成の例
グラムを，図3 のDSL を用いてトップダウン探索
で合成する場合について説明する．仕様は入出力例
[3, 6, 4, 5] →[1, 2] が与えられているとする．図4 で
示すように，トップダウン探索では開始記号から，非
終端記号を含む不完全なプログラムも含めて列挙し
ていき，終端記号のみで構成されたプログラムが現れ
た場合は与えられた仕様に合致するかどうか判定し，
仕様に合致するようであればそのプログラムを出力す
る．今回の例では合成したプログラムに[3, 6, 4, 5] を
入力し，[1, 2] が得られたら仕様に一致しているとみ
なして，そのプログラムを出力する．探索の深さが8
探索目の時，仕様に合ったプログラムが得られるが，
探索回数が増えるほどプログラムの候補が爆発的に
増加するため，最大で900 万個以上のプログラムを
生成しなくてはならない．図3 のような比較的単純
なDSL ですら組合わせ爆発を起こすため，より複雑
なDSL では探索は不可能となる．そのため，膨大な
プログラム空間の中から所望のプログラムを効率的
に探し出す探索技術が必要不可欠となる．
2. 3. 4
調査4：プログラム合成をどのドメインに
適用するか？
プログラム合成の研究は，「高速化等，プログラム
合成技術そのものの性能向上を目指した研究」と「特
定ドメインの課題に対してプログラム合成技術による
解決を目指した研究」の2 つに分けることができる．
本論文ではプログラム合成が今後活躍する可能性の
あるドメインについて理解を深めることを目的とし，
「特定ドメインの課題に対してプログラム合成技術に
よる解決を目指した研究」について調査を行う．
3
既存のプログラム合成技術の概要
本章では本論文の調査対象外である2015 年以前の
プログラム合成の研究について，Gulwani らによる
プログラム合成の調査論文[48] に基き，ユーザの意図
の伝え方，プログラムの探索空間，プログラムの探索
技術の3 つの観点においてそれぞれ簡単に紹介する．
3. 1
ユーザの意図をどのような形式で与えるか？
3. 1. 1
入出力例
所望のプログラムの入出力例によって，ユーザの意
図を表すことができる．図1 で表されるユーザの意
図を満たす入出力例は無数に存在する．例えば入出
力例[3, 6, 4, 5] →[1, 2] はそのうちの1 つである．
入出力例の利点としては，人間にとってわかりやす
く作成も簡単なことと，具体的でありシステムによ
る解釈が容易なことが挙げられる．特に人間にとっ
てわかりやすく作成が簡単という点は重要であり，
FlashFill のようにプログラムに詳しくないエンド
ユーザ(本論文では事務処理等の一般的なタスクを
PC やスマートフォン上で行うユーザと定義する) で
も活用できる可能性を秘めている．
一方，欠点としてはユーザの意図が伝えにくいこと
が挙げられる．多くの場合においてユーザの意図を
表す入出力例のパターンは無限に存在するが，実際に
システムに与える入出力例は有限であり，入出力例は
実現したい仕様のごく一部を表しているに過ぎない．
そのため入出力例を用いたプログラム生成では，与え
られた入出力例は満たすが実現したい仕様には合致し
100
コンピュータソフトウェア
ないプログラムが得られることがある．このようなプ
ログラムを入出力例にオーバーフィットしたプログラ
ムと呼び，所望のプログラムの合成の妨げとなる．例
えば図1 の例において入出力例[3, 6, 4, 5] →[1, 2] が
与えられた時，filter(λx:x<3,map(λx:x-2,ARG))
といったプログラムも入出力例を満たしてしまう．こ
のプログラムは「リストのすべての要素から2 を引
いて3 より小さい値のみを出力」という意味であり，
明らかにユーザの意図に反する．
3. 1. 2
形式仕様
プログラムの性質を形式的に記述した仕様を形式
仕様と呼ぶ．形式仕様にはアサーション，事前事後条
件などが該当する．図1 で表されるユーザの意図を
形式仕様(事後条件) で表す場合を考える．以下の3
つの要件を形式仕様として書き下す必要がある．
• 入力リストの要素から4 が引かれていること.
• 出力リストには0 より大きい値のみが存在して
いること.
• 出力リストがソートされていること.
1 つ目の「入力リストの要素から4 が引かれているこ
と」は例えば以下のような事後条件で表される．
∀i 0 ≤i < len(out) ⇒∃j in[j] −4 = out[i] (1)
ただし，in は入力リスト，out は出力リスト，len(out)
は出力リストの長さを表す．この論理式は，「出力リ
ストのすべての要素において，入力リストのある要素
から4 を引いた値と等しい値が存在する」ことを意
味する．続いて2 つ目の「出力リストには0 より大
きい値のみが存在していること」は以下のように表さ
れる．
∀i 0 ≤i < len(out) ⇒out[i] > 0
(2)
この論理式は，「出力リストのすべての値は0 より大
きい」ことを意味する．最後に「出力リストがソート
されていること」は以下の論理式で表される．
∀i 0 ≤i < len(out)−1 ⇒out[i] ≤out[i+1] (3)
この論理式は，「出力リストのi 番目の要素の値は，
i+1 番目の要素の値以下になる」ことを意味する．こ
れら3 つの論理式をand 演算子で組み合わせること
で，事後条件を表す論理式が完成する．
形式仕様の利点としては，プログラムの性質を式
(1)(2)(3) のように論理式で記述できるためユーザの
意図を伝えやすいことと，具体的でありシステムによ
る解釈が容易なことが挙げられる．一方，形式仕様の
欠点としては式(1)(2)(3) のように，作成に一定のス
キルや知識が必要であることが挙げられる．そのため
エンドユーザがプログラム合成を行うことを想定し
ているようなドメインには不向きである．またユー
ザの意図を漏れなく表現する形式仕様を記述するこ
とは難しく，記述が不十分であれば入出力例と同様に
オーバーフィットしたプログラムが生成されうる点に
は注意が必要である．例えば式(1)(2)(3) の例では，
filter(λx:x==1,map(λx:x*0,ARG)) のように入力
値に関わらず常に空のリストを返すようなプログラ
ムも仕様を満たしてしまう．このようなプログラム
を回避するためには，「入力リストにおいて，値が4
より大きい要素の個数が出力リストの要素の個数と
一致する」等の情報を新たに論理式で書き下し，仕様
に追加しなくてはならない．
このようにユーザが最初から漏れのない仕様を書
き下すことは難しい．そこで文献[67] では，ユーザ
は合成されたプログラムを確認し，意図と異なるプロ
グラムであれば仕様を修正して再び合成するという
対話型の合成が望ましいと述べている．
3. 1. 3
自然言語
自然言語で記述されたプログラムの仕様を入力と
して用いる研究も存在する．図1 で表されるユーザ
の意図を自然言語で表した場合の一例として，「リス
トのすべての要素から4 を引いて，0 以下の値を削除
し，ソートした状態で出力する」等が挙げられる．
自然言語の利点としては，単純な仕様であればプロ
グラムに詳しくないエンドユーザでも簡単に記述で
き，また上記の例のようにユーザの頭の中にある意
図を直接表現しやすいことが挙げられる．NLyze [47]
ではスプレッドシートの表に対するフィルタリング
等を行うプログラムを自然言語で記述された仕様か
ら合成することで，エンドユーザでも簡単に表の操作
を行うことを可能としている．一方，自然言語の欠点
としては，曖昧性がありシステムによる解釈が難しい
ことが挙げられる．そのため仕様を正しく網羅的に
記述できていても，ユーザの意図に反するプログラム
が生成される可能性がある．
Vol. 40
No. 2
May 2023
101
3. 2
プログラム空間をどう定義するか？
3. 2. 1
スケッチ
ソースコード1
スケッチ言語で記述されたプログラムの例
1 void main(int x){
2
int y = x * ??;
3
assert y == x + x;
4 }
2. 3. 2 項ではDSL を設計することで探索空間を狭
める方法を紹介した．DSL はなるべく少ないコンポー
ネントで特定ドメインを表現できるように工夫して
設計することで探索空間を狭めることが可能であり，
これはDSL 設計者の対象ドメインの知識を活用する
ことで探索空間を狭めていると言える．一方でプロ
グラム合成のユーザの知識を活用することで探索空
間を狭めるスケッチと呼ばれる手法も存在する．
スケッチを用いたプログラム合成は，作成したいプ
ログラムについて事前にユーザがわかっている箇所
はユーザが記述し，残りの部分を合成する．ユーザが
作成する部分的に穴の開いた不完全なプログラムを
スケッチと呼ぶ．スケッチをベースにプログラム合
成を行うことで，探索空間を削減することができる．
例えば図1 において最後にリストをソートすること
をユーザが知っている場合，sort(<hole>) のような
スケッチを与えることができる．ただし<hole>はプ
ログラム中の穴を意味し，何らかのコンポーネントが
挿入されることを示す．上記のようなスケッチを与え
ることで，図1 の例における探索数は最大約94 万回
程度になり，探索空間を約9 割削減できる．スケッチ
はプログラムについて部分的に知っていることが求
められるため，プログラマの支援などに用いられる．
スケッチ言語[120] は分岐等の制御構造は人がス
ケッチとして記述し，演算部分はプログラム合成に
よって合成することが可能な技術である．例えばソー
スコード1 のように人がプログラムの構造とアサー
ションを記述し，不明な箇所は??(プログラム中の穴，
<hole>と同義) を指定することで自動で穴を満たす値
(ソースコード1 では??に「2」が入る) を生成する．
3. 2. 2
Syntax-Guided Synthesis
2. 3. 2 項で紹介したDSL をシステムに認識させる
ためには，予め決められた記法で記述する必要があ
る．しかしプログラム合成ツールごとに独自の記法
を設計することは非効率的であり，また独自記法の知
識がないユーザにとってもカスタマイズしにくいと
いった欠点がある．Syntax-Guided Synthesis [3](以
下SyGuS) はプログラム合成問題の形式化に対する
取り組みである．SyGuS では仕様やDSL の記法を
規定したSyGuS 言語を提供している．それにより，
プログラム合成ツール作成の効率化と，SyGuS 言
語の知識を持ったユーザによるカスタマイズの容易
化を実現している．またプログラム合成問題の共通
的なベンチマークの作成も可能である．SyGuS の公
式サイト†5 によると，SyGuS 言語で記述された合
成問題に対するソルバの性能を競うコンペティショ
ンが，国際会議CAV (International Conference on
Computer-Aided Veriﬁcation) の併設ワークショッ
プSYNT Workshop で2015 年から2019 年にかけ
て開催されている．このコンペティションを通じて，
CVC4 [8] 等の優れたソルバが頭角を現すきっかけと
なっており，プログラム合成の発展の一翼を担って
いる．
与えられた2 つの引数のうち大きい値を返すmax2
関数の合成問題をSyGuS 言語で記述した場合の例を
図5 に示す．合成問題は主にコンポーネントの定義
と仕様の定義部分に分けられる．コンポーネントの
定義では，合成で使用するDSL を定義する．図5 の
場合，x や0 などの定数や変数，+や-などの算術演算
を行うオペレータ，分岐を制御するite(if then else
の略)，and や=などの条件演算子が定義されている．
仕様は形式仕様等で記述する．図5 の場合max2 関数
の仕様として，以下の条件が定義されている．
• 出力は引数x 以上であること.
• 出力は引数y 以上であること.
• 出力は引数x もしくはy のどちらかと等しい.
図5 の問題を解くことで，(define-fun max2 ((x
Int) (y Int)) Int (ite (>= x y) x y)) などの
†5
https://sygus.org/
102
コンピュータソフトウェア
;; 合成される関数の名前とシグネチャ
(synth-fun max2 ((x Int) (y Int)) Int
    
    ;; 文法で使用される非終端記号の宣言
    ((I Int) (B Bool))
    ;; max2 の実装を許可する文法の定義
    ((I Int (x y 0 1
             (+ I I) (- I I)
             (ite B I I)))
     (B Bool ((and B B) (or B B) (not B)
              (= I I) (<= I I) (>= I I))))
)
(declare-var x Int)
(declare-var y Int)
;; 関数に対する意味的制約の定義
(constraint (>= (max2 x y) x))
(constraint (>= (max2 x y) y))
(constraint (or (= x (max2 x y)) (= y (max2 x y))))
(check-synth)
コンポーネントの
定義
仕様の定義
図5
SyGuS 言語で定義された合成問題の例
プログラムが得られる．SyGuS 言語を用いることで
様々な合成問題を表現することが可能である．
3. 3
プログラム空間をどう探索するか？
3. 3. 1
Enumerative(列挙探索)
列挙探索ではプログラムを何らかの基準に基づい
て列挙していくことで，仕様を満たすプログラムを探
索する手法である．基本的な探索方法として，トップ
ダウン探索とボトムアップ探索の2 種類が存在する．
トップダウン探索では図4 で示すように，開始記
号から，非終端記号を含む不完全なプログラムも含め
て列挙していき，終端記号のみで構成されたプログラ
ムが現れた場合は与えられた仕様に合致するかどう
か判定し，仕様に合致するようであればそのプログラ
ムを出力する．トップダウン探索は3. 3. 2 項で紹介
する演繹的手法等と組み合わせることで探索空間の
枝刈りが可能である．
ボトムアップ探索では終端記号のみで構成されるプ
ログラムをサイズが小さい順に，仕様に合致するプロ
グラムが得られるまで列挙する．終端記号のみで構成
されるプログラムを列挙するため探索中に得られるプ
ログラムはすべて実行可能という特徴がある．観測的
等価性による探索空間の枝刈り[2] はその特徴を利用
しており，探索中に得られた複数のプログラムにおい
て，いくつかの入力に対する出力の値が全て一致した
場合，それらのプログラムは等価とみなす．例えば図3
のDSL で合成されるプログラムにおいてsort(ARG)
とsort(sort(ARG)) は任意の入力の実行時に同一
の値を返す．よってsort(ARG) とsort(sort(ARG))
は等価とみなし，以降sort(sort(ARG)) を部分的に
含むプログラムを生成しないようにすることで探索
空間の枝刈りが可能である．ただし観測的等価性は
一部の入出力でのみ判定を行っているため，厳密な等
価性は保証していないことには注意が必要である．
3. 3. 2
Deductive(演繹的手法)
演繹的手法とは，仕様を分割することで探索を
効率化する手法である．例えば図4 において，1
探索目に登場するmap(Fi,L) の第二引数L の仕
様はlen(L) = 2 となる．なぜならmap は常に第
二引数で与えられるリストと同じ長さのリストを
返すため，第二引数と出力例のリストのサイズは
必ず一致しなくてはならないためである．よって
len(L) = 2 となるようなL を探索するという問題
に縮小でき，それによって例えばmap(Fi,ARG) は
len(ARG) = len([3, 6, 4, 5]) = 4 ̸= 2 となり仕様を
満たさないため探索から安全に除外できる．ただし演
繹的手法を用いる場合は，関数に対する仕様(上記の
例の場合，map の仕様はlen(in) = len(out) となる)
が必要である．
FlashMeta [100] は入出力例を用いた演繹的なプロ
グラム合成を実現するための汎用フレームワークで
ある．開発者はFlashMeta にDSL と関数仕様を与
えることで入出力例を用いたプログラム合成ツール
を開発できる．FlashMeta は与えられた関数仕様に
基づいて仕様(出力例) を分割する．例えば出力例と
してE が与えられ，候補プログラムとしてF(引数1,
引数2) が与えられているとする．ただしF は引数を
2 つ持つ何らかの関数とする．FlashMeta では，事前
に与えられたF の仕様に基づいて，出力例E を引数
1 に入るプログラムが返すべき出力E1 と引数2 に入
るプログラムが返すべき出力E2 に分割し，それぞれ
の出力に対する探索問題に変換することで探索を効
Vol. 40
No. 2
May 2023
103
率化する．
3. 3. 3
Constraint Solving(制約解消法)
制約解消法とは，プログラム合成問題を制約に変換
し，SMT ソルバ等の制約ソルバを用いて制約を解く
ことで所望のプログラムを得る手法である．プログ
ラム合成問題全体を制約に変換して解く手法[62] や
スケッチと組み合わせる手法[120] 等が存在する．ス
ケッチと組み合わせる手法の例を示す．ソースコー
ド1 のスケッチは，?? をc としたとき，以下の制約
式に変換できる．
∃c x ∗c = x + x
(4)
この制約式をSMT ソルバを用いて解くことでc = 2
が求まり，??には「2」が入ることがわかる．
制約解消法は強力である一方で，制約式が複雑な場
合，制約ソルバで解くことができないことが知られてい
る．そこで反例駆動型帰納的合成(Counterexample-
guided inductive synthesis，以下CEGIS) [121] と呼
ばれる手法が存在する．CEGIS の全体像を図6 に示
す．CEGIS は入出力例セットをすべて満たすプログ
ラムを合成する合成器と，合成された候補プログラム
が仕様に合うかどうか判定し，仕様に合わない場合は
反例を生成する検証器から構成される．生成された
反例は入出力例セットに追加され，次の合成に使用さ
れる．
反例を含む具体的な入出力例を用いることで制約式
中の変数の数が減り，制約ソルバで解きやすくなると
いうメリットがある．例えば反例として1 という値が
与えられている場合，式(4) は以下の制約式になる．
∃c 1 ∗c = 1 + 1
(5)
式(5) では入力変数x が具体的な値に置き換わり，変
数の数が減っていることがわかる．またCEGIS では
検証のためにも制約ソルバが用いられているが，一般
的にある仕様を満たすプログラムを合成するよりも，
与えられたプログラムが仕様を満たすかどうか検証
する方が簡単と言われている[120]．CEGIS ではこの
ように制約ソルバの負担を減らすことで，最初から仕
様を満たすプログラムを合成することが難しい問題
でも，合成と検証のプロセスの繰り返しによってプロ
グラムを合成できる可能性がある．
図6
CEGIS の全体像
3. 3. 4
Statistical(統計的手法)
統計的手法では，確率モデルや評価関数等を用いて
プログラム空間の探索を行う．Menon らの手法[82]
では，事前に人手で設定した規則に基づいて，入出力
例と使用されるDSL のコンポーネントの関係性を学
習する．事前に人手で設定した規則とは例えば「入力
リストには重複があるが出力リストには重複がない
場合，重複を排除するdedup 関数を使用」等であり，
学習を進めることで入出力例ごとに適用するべき規
則を確率的に推論できる．
確率モデルを用いたプログラム合成では機械学習
等を用いて自動でモデルを導出するのに対し，ヒュー
リスティック探索では人間の経験則に基づいた探索
ルールを評価関数で書き下す．プログラム合成の場
合，評価関数は候補プログラムの仕様への近さを定量
的に評価することが求められ，例えば仕様となる複数
の入出力例のうち，候補プログラムが満たしている数
などが用いられる[44]．ヒューリスティック探索のア
ルゴリズムの1 つとして遺伝的アルゴリズムが存在
し，遺伝的アルゴリズムをプログラム合成に適用した
手法を遺伝的プログラミング[69] と呼ぶ．遺伝的プ
ログラミングでは生物の進化を模倣し，プログラムを
選択，交叉，突然変異によって進化させていく．選択
では評価関数の値が優れた個体を次の世代(選択，交
叉，突然変異の1 プロセスを意味する) へ残す．交叉
では2 つのプログラムの遺伝子(コード片) を組み合
わせることで新しいプログラムを生成する．突然変異
ではプログラムの遺伝子を無作為に変化させる．この
ようなプロセスによって，徐々に評価関数の値が優れ
104
コンピュータソフトウェア
たプログラムへと進化していき，最終的に評価関数を
満たす(つまり仕様を満たす) プログラムを生成する．
3. 3. 5
バージョン空間代数
プログラム合成では，複数の候補プログラムを保持
しなくてはならない場合がある．例えば仕様が少量
の入出力例で定義されているなど，ユーザの意図のご
く一部しか表現できていない場合，オーバーフィット
を防ぐために仕様を満たすプログラムを列挙してか
ら最もユーザの意図にあっていると判断したプログ
ラムを出力する場合がある．しかし候補プログラム
の数は膨大になりうるため，プログラムの集合を効率
的に保持，操作する手法が求められる[138]．
そこでバージョン空間代数(Version Space Alge-
bra，以下VSA) を用いることで複数のプログラムを
コンパクトに表現することができる．例えば図7 に
示すように，入力された文字列の先頭三文字目から最
後の文字までを取り出したいとし，入出力例として
“abaaab” →“aaab” が与えられているとする．ただ
しARG は入力文字列を，str any は任意の文字列を，
len(ARG) は入力文字列の長さを，subStr(ARG,I,I)
はARG から第二引数I+1 番目から第三引数I まで
の位置の文字列を抽出する関数を表す．入出力例を
満たすプログラムは，"aaab"，subStr(ARG,2,5)，
subStr(ARG,2,len(ARG)-1) の3 つとなる．これら
のプログラムをVSA で表すと，以下のようになる．
U("aaab", subStr(ARG,2,
U(5,len(ARG)-1)))
(6)
ただしU はユニオンノードであり，プロ
グラムの集合の和を表す．式6 を図で表す
と，図8 のようになる．subStr(ARG,2,5) と
subStr(ARG,2,len(ARG)-1) の共通部分が括りださ
れ，コンパクトな表現になっていることがわかる．
3. 3. 2 項で紹介したFlashMeta は候補プログラム
の保持にVSA を用いている．FlashMeta ではプログ
ラムの集合に対して何らかの操作を行うことがある．
例えば入出力例が複数存在する時，各入出力例を満た
すプログラムの集合から共通のプログラムを抜き出
す等である．VSA でプログラムの集合をコンパクト
に表現することで，プログラムの集合に対する操作を
効率的に行うことを可能にしている．
仕様(入出力例)：“abaaab” →“aaab”
開始記号string S
::=
subStr(ARG,I,I) |
str any
int I
::=
0 | 1 | 2 | 3 | 4 | 5 |
len(ARG)-I
図7
文字列操作のプログラム合成問題の例
図8
VSA によるプログラム表現
4
調査結果1：ユーザの意図をどのような形
式で与えるか？
調査結果1 を表1 に示す．ただし複数の形式の仕
様を用いている場合は，それぞれの仕様の形式として
カウントしている．
4. 1
入出力例
今回の調査で最も多かった形式が，入出力例であ
る．入出力例は人間にとってわかりやすい形式であ
り，プログラム合成の実用化を目指した研究では入出
力例が使われることが多い．例えばスプレッドシー
ト†6 の表のフィルタリングを行うプログラムの自動
生成を目指した研究[135] では，フィルタリング前後
の少量のデータを入出力例として使用している．他に
も，XML ドキュメント等の木構造データの変換を行
うプログラムの自動生成を目指した研究[140] では，
変換前後の木構造データを入出力例として使用してい
る．これらの研究は簡易な入出力例からその変換を実
現するプログラムを自動生成し，その後，実際に変換
したい大量のデータに対してそのプログラムを用いて
†6
https://www.google.com/intl/ja jp/sheets/
about/
Vol. 40
No. 2
May 2023
105
表1
仕様の形式と年ごとの論文数の推移
年数
2016
2017
2018
2019
2020
合計
入出力例
8
11
21
17
24
81
形式仕様
3
5
6
6
5
25
自然言語
3
3
2
6
7
21
　
入出力例：[5]–[7][9][12][13][18]–[25][27]–[29][31]–[39][42][46][50][51][55][58][60][61][64]–[66][70]–[72][76][79][84]–[87]
[90]–[96][101][102][105]–[109][111][113]–[115][117]–[119][123][127][128][130]–[135][140][145][146][148][149]
形式仕様：[1][4][15][16][26][41][49][53][54][56][57][59][68][77][78][80][81][84][97]–[99][104][116][119][136]
自然言語：[21][24][30][42][73]–[75][88][89][103][112][122][124][125][137][139][141]–[144][147]
変換を行うことを想定している．人が行う作業は簡
易な入出力例の作成のみであるため，プログラムの知
識に乏しい人でも大幅な作業の効率化が期待できる．
また入力例のみからプログラムを生成する研究も
存在する[46][107]．これらの研究では，与えられた入
力例に対して様々なプログラムを生成し，優れた出力
が得られるプログラムを探索する．優れた出力の例
は，ショッピングサイトから情報を抽出するような
ケースにおいて，商品の情報が網羅的に抽出されてい
る[107]，混在したフォーマットのデータを統一でき
る[46] 等である．入力例のみからプログラムを生成
する利点としては，出力例を作成する手間が不要であ
り，また処理の対象となるデータを入力例としてその
まま活用できるため，様々な種類のデータ変換を行う
必要がある時にバッチ処理できることが挙げられる．
一方，出力例のみからプログラムを生成する研究も
存在する[12][27][33][55][70][72][90][123][127]．これら
の研究は出力例として与えられたデータをプログラ
ムとして表現することが目的である．文献[27] では，
ユーザが与えた図形を出力するプログラムを自動生
成している．図形を，それを描画するプログラムコー
ドとして表現することで，直接図形に操作を行うより
も図形のメンテナンスや使い回しが容易になる．文
献[12] では，1 つのUI デザインから様々なデバイス
で同一のUI を表示するプログラムを生成することを
目的にしている．
3. 1. 1 項で述べたように入出力例の欠点としては，
与えられた入出力例にオーバーフィットしたプログ
ラムが生成されてしまうことであり，オーバーフィッ
トを防ぐことを目的にした研究も存在する．文献[5]
では入力変数の順番を変えても結果が変わらないよ
うなプログラムにおいて，入出力例を自動的に水増し
することでオーバーフィットしたプログラムが生成
される可能性を低減させている．例えば与えられた2
つの数値型の入力から最大の値を返すようなプログ
ラムを生成する場合を考える．ユーザは入出力例と
して1, 2 →2 を与えたとする．この時，λ(x,y):y と
いった入出力例にオーバーフィットしたプログラム
が生成されうる．そこで入力の性質に着目する．今
回の例では与えられた入力の中で最大の値を返すこ
とが目的であり，入力変数の順番を入れ替えても結果
は変わらない．そのため2, 1 →2 といった入出力例
を自動的に生成することができ，入出力例の水増しが
できる．この入出力例を加えることで，λ(x,y):y と
いった入出力例にオーバーフィットしたプログラム
を排除することができる．
4. 2
形式仕様
3. 1. 2 項で述べたように形式仕様はユーザの意図を
伝えやすい反面，作成に一定のスキルが必要なため，
専門的なプログラムの合成に用いられることが多い．
Cozy [77] では，データ構造やクエリの仕様から，最
適化されたデータ問い合わせプログラムを合成して
いる．
また形式仕様を使用したプログラム合成問題は，
3. 2. 2 項で紹介したSyGuS 言語で記述している研究
106
コンピュータソフトウェア
も多かった[1][4][53][54][56][57][116][136]．SyGuS 言
語は形式仕様記述をサポートしており，またベンチ
マークとなる問題も多数存在するため，形式仕様を使
用したプログラム合成の研究に大きく貢献している
と言える．
4. 3
自然言語
3. 1. 3 項で述べたように自然言語はプログラミング
に詳しくないユーザでも扱うことができるため，作成
が容易である．そのためプログラミングの知識が乏し
いエンドユーザを対象にした研究が多い．例えば文
献[30] は，簡単なテキスト編集やシステムへの問い
合わせ等のエンドユーザが直面する可能性があるタ
スクに対し，自然言語からプログラムを生成する手法
を提案している．文献[75] は，自然言語からIf-Then
プログラムを生成する手法を提案している．If-Then
プログラムはトリガーとアクションを持ち，トリガー
が発動した時にアクションを実行する．これにより，
「新しく写真が追加されたら，クラウドにバックアッ
プを取る」等の単純だがエンドユーザにとっては自動
化が困難なタスクを，自然言語で記述するだけで自動
化できる．
一方，自然言語の欠点としては，曖昧性がありシス
テムによる解釈が難しいことが挙げられる．そのた
めシステムによる解釈が容易な，入出力例等の他の
仕様形式と組み合わせる研究も存在する[21][24][42]．
例えば文献[21] では，自然言語で記述された仕様情
報からスケッチを生成し，その後入出力例を満たすよ
うにスケッチの穴埋めを行う．自然言語の曖昧性を
具体性がある入出力例で補い，入出力例の情報量の少
なさを意図を伝えやすい自然言語で補っており，互い
に相補の関係にあると言える．他にも文献[42] では，
自然言語から生成されたロボット制御の複数の候補
プログラムについて，ユーザに動作例を見せて選択さ
せることで曖昧さを解消している．
5
調査結果2：プログラム空間をどう定義す
るか？
調査結果2 を表2 に示し，以下に詳細を説明する．
5. 1
事前に使用するコンポーネント集を定義
2. 3. 2 項で紹介した，ドメインごとに事前に設計
したDSL を用いる方法が今回の調査でも最も多かっ
た．例えば文献[130] ではSQL の合成，文献[135] で
はデータのフィルタリング，文献[117] では日付，時
間等のデータタイプ統一のためのDSL の設計を行っ
ている．
2. 3. 2 項で述べた通り，DSL の設計では表現力と探
索空間の大きさの両方を考慮しなくてはならず，設計
には専門性とコストが求められる．実際に文献[135]
ではオンラインヘルプフォーラムや他の産業ソース
から収集した実世界のベンチマーク問題に対する大
規模な実証研究に基づいて繰り返し設計することで，
最終的に効率的なDSL を作成している．更に演繹的
手法(3. 3. 2 項参照) を用いる場合は各関数に対する
仕様も設計する必要がある．有用な仕様を検討する
ことはドメインの専門知識とプログラム合成に関す
る知識の両方を必要とするため，より深い専門性が求
められる．そこで文献[132] では各関数に対する適切
な仕様の設計を自動で行うことで，DSL の設計を容
易化している．
3. 2. 2 項で紹介したSyGuS 言語を用いた研究も多く
存在した[1][4][7][51][53][54][56][57][64][71][116][133][136]．
文献[54][71] ではSyGuS のコンペティションの問題
をベンチマークとして用いることで，過去にコンペ
ティションで成果を挙げた技術との公平な比較評価を
実現している．また2016 年以降も，コンペティショ
ンを通じてEUSolver [4] 等の優れたソルバが登場し
ており，プログラム合成の発展へ貢献している．
5. 2
合成の度にコンポーネント集をユーザが指定
DSL を用いたプログラム生成の欠点として，プロ
グラムの表現力が低いことが挙げられる．一般的に
はDSL 中で使用するコンポーネント数は数十個程度
であり，その組み合わせで表されるプログラムしか生
成することができない．より広いドメインでのプロ
グラム生成を実現するため，ユーザが合成の度に指定
したコンポーネントを用いてプログラム合成を行う
研究も存在する．文献[111] では，Java の一般的な関
数の生成を目的とし，合成中に使用されるライブラリ
Vol. 40
No. 2
May 2023
107
表2
プログラム空間の定義方法と年ごとの論文数の推移
年数
2016
2017
2018
2019
2020
合計
事前に使用するコンポーネント集を定義
13
15
27
20
30
105
合成の度にコンポーネント集をユーザが指定
0
2
1
2
1
6
コンポーネントの定義は不要
1
2
0
5
3
11
　
事前に使用するコンポーネント集を定義：[1][4]–[7][9][12][13][15][16][18]–[35][38][39][41][42][46][50][51][53]–[61]
[64]–[66][68][70]–[73][75]–[79][81][84]–[87][89]–[99][101][102][104]–[109]
[113]–[119][122][123][127][128][130]–[136][140][141][145][146][148][149]
合成の度にコンポーネント集をユーザが指定：[36][37][49][80][88][111]
コンポーネントの定義は不要：[74][103][112][124][125][137][139][142]–[144][147]
関数をユーザが指定することで実現している．
これらの手法はユーザが指定する手間がかかり，ま
たプログラムの知識があることが前提となるが，プロ
グラマが関数を記述する際は使用するライブラリを
把握していると考えられるため，プログラマを支援
する方法としては有用である．またユーザの知識を
活用するという点においては3. 2. 1 項で紹介したス
ケッチと同様であるが，プログラムの部分的な構造で
はなく使用する可能性のあるコンポーネントを指定
するという点で異なる．そのため，作成したいプログ
ラムの構造が不明な場合にも有用である．
5. 3
コンポーネントの定義は不要
文献[124][125] 等の既に存在するJava やPython
等の一般的なプログラムをデータセットとして学習
することを想定した研究では，コンポーネントの定義
は不要である．ただし当然ながら学習データに含ま
れないコンポーネントを使用したプログラムを合成
することはできない．
6
調査結果3：プログラム空間をどう探索す
るか？
調査結果3 を表3 に示す．ただしFTA は有限木
オートマトン(Finite Tree Automaton)，TTN は型
遷移モデル(Type Transition Nets) の略である．ま
た複数の手法を用いている論文は最も貢献が大きい
と判断した手法に分類した．各手法が同程度の貢献
の場合は，それぞれの手法を使用した論文としてカウ
ントしている．
6. 1
優先探索
優先探索とは所望のプログラムに近いと考えられ
るプログラムから優先的に探索する方法である．本
節では6 つの方法を紹介する．
6. 1. 1
確率モデルによる探索のガイド
確率モデルによる探索のガイドとは，事前に作成し
た深層学習モデル等の確率モデルによって，所望のプ
ログラムで使用される可能性が高いと推測されるコ
ンポーネント，もしくは所望のプログラムに近いと推
測されるプログラムを優先的に探索する手法である．
DeepCoder [6] では，入出力例とプログラム中に使
用されているコンポーネントの関係性を深層学習モ
デルによって学習することで，未知の入出力例が与え
られた時に，使用される可能性が高いコンポーネント
を推測し，そのコンポーネントから優先的に探索して
いる．DeepCoder [6] は入出力例からコンポーネント
の使用確率を予測するという非常にシンプルなモデ
ルのため，汎用性が高く様々な手法に適用できる．し
かし一方で，コンポーネントをどう組み合わせるかに
ついては学習に含まれないため，コンポーネント数の
多い複雑なプログラムを生成するには不向きである
といった指摘もある[149]．そのため文献[23][149] で
は，合成途中のプログラムの状態を深層学習モデルへ
の入力とすることで，複雑なプログラムの生成を可能
108
コンピュータソフトウェア
表3
プログラム空間の探索方法と年ごとの論文数の推移
年数
2016
2017
2018
2019
2020
合計
優先探索
確率モデルによる探索のガイド
1
2
6
2
6
17
72
系列データ変換モデルによる探索
2
3
2
6
4
17
雛形生成によるプログラム合成
0
3
1
4
3
11
強化学習を用いたプログラム合成
0
0
3
2
3
8
学習データや学習方法の工夫
0
0
0
1
2
3
ヒューリスティック探索
2
3
4
5
2
16
探索空間
の枝刈り
制約解消法による枝刈り
1
5
0
4
2
12
32
演繹的手法による枝刈り
6
1
6
2
5
20
グラフを
用いた探索
VSA を用いた探索
2
0
3
1
1
7
14
FTA を用いた探索
0
1
2
0
1
4
TTN を用いた探索
0
1
0
0
2
3
仕様情報を追加
しながら合成
CEGIS
2
2
4
1
2
11
17
対話型プログラム合成
0
1
0
0
5
6
　
確率モデルによる探索のガイド：[6][9][12][23][30][42][65][66][70]–[72][89][95][113][122][146][149]
系列データ変換モデルによる探索：[29][31][33][74]–[76][92][103][123]–[125][127][137][139][142]–[144]
雛形生成に基づいた探索：[21][24][36][50][88][91][112][130][141][145][147]
強化学習による探索：[19][22][25][32][55][73][87][116]
ヒューリスティック探索：[13][20][26]–[28][54][60][86][90][105]–[107][109][111][115][128]
制約解消法による枝刈り：[5][15][21][24][34][36][37][41][57][80][97][119]
演繹的手法による枝刈り：[4][16][25][35][38][39][56][59][68][78][79][84][94][98][99][108][118][131][132][140]
VSA を用いた探索：[58][65][66][85][94][117][135]
FTA を用いた探索：[51][133][134][136]
TTN を用いた探索：[37][49][61]
CEGIS：[1][16][53][57][59][77][81][102][104][136][148]
対話型プログラム合成：[18][42][46][64][96][101]
としている．例えば文献[23] は，合成途中のプログ
ラムを実行し，得られた出力を現在のプログラムの状
態と捉え，深層学習モデルに与えている．
文献[113] は合成途中のプログラムの出力情
報の活用に加えて，プログラムではなく実行
トレースを学習することで，学習精度を向上
させている．実行トレースとは，実際にプロ
グラムを動かした時に実行されるアクション
の列である．例えばwhile(4 times): action()
というプログラムの実行トレースは，
action() action() action() action() になる．
ただしwhile(n times): action() はaction() を
n 回繰り返すことを意味する．実行トレースでないプ
ログラムをそのまま学習する場合は，while() の意
味と，action() を実行した際の状態変化の2 種類を
学習しなくてはならないが，実行トレースを学習する
場合は後者だけで済むため，学習がしやすいと考えら
れる．このように様々な工夫が提案されているが，文
献[23][113][149] は合成途中のプログラムが実行可能
なことを前提としているため，トップダウン探索のよ
Vol. 40
No. 2
May 2023
109
うな探索過程で実行不可能なプログラムも候補に含
むような手法への適用はできないということには注
意が必要である．
仕様情報固有の特徴を生かして，探索をガイドする
手法も存在する．文献[12][70] では，UI レイアウト
からプログラムを自動合成する目的において，UI レ
イアウトとしての妥当性を学習することで探索をガ
イドしている．具体的には，実在する様々なUI レイ
アウトデータから「UI レイアウトらしさ」を判定す
るモデルを学習し，合成途中の候補プログラムが生
成するUI レイアウトに対して「UI レイアウトらし
さ」が高いプログラムを優先的に列挙していくことに
より，効率的な探索を実現している．文献[30][42][89]
では，自然言語で記述された仕様に対して，自然言語
解析技術を用いることで探索をガイドしている．例え
ば文献[30] は，自然言語で書かれた仕様に登場する
単語をWordNet†7 を用いて意味的に近い名前を持つ
DSL のコンポーネントに変換し，それらをDSL で定
めた型制約を満たすように組み合わせることでプロ
グラムを生成している．
6. 1. 2
系列データ変換モデルによる探索
系列データ変換モデルを用いたプログラム合成技術
が存在する．系列データとは，何らかの同種のデータ
が並んだデータを指す．例えば自然言語は単語の羅
列で構成されるため，系列データである．近年，系列
データを別の系列データに変換する深層学習モデル
の研究が盛んに行われている．代表的なモデルとし
ては，Sequence to Sequence [126](Seq2Seq) がある．
Seq2Seq の全体像を図9 に示す．Encoder は入力さ
れた系列データを特徴ベクトルに変換し，Decoder は
その特徴ベクトルに基づいて新しい系列データに変
換するといった仕組みである．対応付いた2 種類の
系列データ(例えば日本語の文章とそれを翻訳した英
語の文章など) をこのSeq2Seq に学習させることで，
系列データ間の変換を行うことができる．Encoder
とDecoder にはリカレントニューラルネットワーク
(RNN) 等のニューラルネットワークが用いられる．
RNN はニューラルネットワークの一種であり，トー
†7
https://wordnet.princeton.edu/
クンを1 つ1 つ順番に読み込んで特徴ベクトルに変
換するモデルである．Decoder が新しい系列データ
を生成する時は，Decoder 内部の確率モデルが推測
する値に基づいて，もっとも可能性が高いデータを1
つ1 つ(自然言語なら単語単位) 出力する．Seq2Seq
は機械翻訳や文書要約などに適用され，大きな成果を
挙げている．プログラム合成で入力となる自然言語や
入出力例等の仕様は系列データであり，また出力とな
るプログラムもトークンの集まりであり，系列データ
である．そのためSeq2Seq のような系列データ変換
モデルをプログラム合成に応用する研究が存在する．
RobustFill [31] では，入出力例からプログラムの
変換をSeq2Seq を用いて行っている．入出力例を満
たすプログラムを実際にプログラムを実行すること
によって確かめながら探索する従来のプログラム合
成とは異なり，「入出力例を満たしそうなプログラム」
を推測するRobustFill は，出力されたプログラムが
入出力例を満たすことは保証しない．ただし，実世界
で与えられる入出力例にはタイプミス等のノイズが
存在する場合もあり，そのような場合は入出力例を必
ず満たすプログラムを探索する従来のプログラム合
成技術では対応できず，入出力例のノイズに対して柔
軟性があるRobustFill の方が優れている．
自然言語で書かれた仕様を系列データ変換モデルで
プログラムに変換する研究も存在する[124][125]．こ
れらの研究は，リカレントニューラルネットワーク
(RNN) が多くのトークンから構成されるシーケンス
の長いプログラムを学習することが困難であることに
着目している．プログラムの場合，変数の定義と参照
等の関連する情報同士が遠く離れた箇所に存在する場
合がある．そのため，RNN では，離れた箇所に存在
する関連した情報を適切に解釈することが困難であ
る．そこで文献[124] では畳み込みニューラルネット
ワーク(CNN) を，文献[125] では，Transformer [129]
を導入している．CNN もTransformer もニューラル
ネットワークの一種であり，これらのモデルはプログ
ラム全体の構造に一度に着目するため，離れた箇所に
存在する情報同士の関係性も学習することが可能で
ある．
また文献[125] では，文法規則やプログラムを抽象
110
コンピュータソフトウェア
図9
Seq2Seq の全体像
構文木にした時の構造も含めて学習することで更に
精度を向上させている．文献[137][142] では，コード
要約(プログラムから自然言語への変換) とコード生
成(自然言語からプログラムへの変換) が互いに関連
したタスクであることに着目し，互いに協同して学習
させることでコード生成の精度を向上させている．
6. 1. 3
雛形生成に基づいた探索
雛形生成に基づいた探索とは，何らかのプログラム
合成手法で所望のプログラムに近いと想定されるプ
ログラムのスケッチを生成し，その後その雛形を仕様
に合うように修正することで所望のプログラムを得
る方法である．スケッチの生成と修正では別の合成
アルゴリズムが用いられる．
最も多いパターンは，6. 1. 2 項で紹介した系列デー
タ変換モデルとその他のプログラム合成手法の組み
合わせである．系列データ変換モデルは非常に強力
であるが，学習データが少ない場合やプログラムが
複雑な場合，仕様を満たす完全なプログラムを生成
することは難しい．そこで系列データ変換モデルで
スケッチを生成した後，仕様に合うように修正する．
文献[24] では，自然言語と入出力例の両方を入力と
し，まず自然言語から系列データ変換モデルでスケッ
チを生成し，その後，そのスケッチに基づいて入出力
例を満たすプログラムを探索している．自然言語は
ユーザの意図を表しやすいが，曖昧性があり，入出
力例はユーザの意図を表しにくいが，曖昧性がない．
よって自然言語からプログラムの大枠を作り，その後
入出力例を満たすように修正するといった手法は，そ
れぞれの情報の短所を補い合う手法と言える．
文献[88][112] は，プログラムには学習を妨げる低
レベルな特徴が含まれていると指摘している．低レ
ベルな特徴とは，変数名などのプログラムの意味に直
接関係してこない情報である．そこでそのような低
レベルの情報を削除したスケッチの状態で学習する
ことで，学習の精度を向上させている．スケッチを生
成した後は，6. 1. 1 項で紹介した確率モデルによる探
索のガイド等を使用して仕様を満たすプログラムを
生成している．
また自動バグ修正技術と組み合わせた研究も存在
する．文献[50][141] ではスケッチを生成した後，自
動バグ修正技術を用いることで仕様を満たすプログ
ラムを生成している．スケッチは，所望のプログラム
に類似しているが仕様を満たさないという点におい
てバグのあるプログラムと考えることもでき，そのよ
うな特徴を利用した手法であると言える．
6. 1. 4
強化学習による探索
強化学習による探索も有望なアプローチの1 つで
ある．まずは強化学習の一般的なフローについて説明
する．強化学習には，エージェントと環境が存在し，
以下のステップを繰り返し行う．
1. エージェントは環境に対して行動を起こす
2. 行動によって環境の状態が変化する
3. 状態に応じた報酬が決まる(良い状態になって
いれば良い報酬，そうでなければ悪い報酬を与
える)
4. エージェントは状態と報酬を受け取り，方策を
更新する
上記のステップを繰り返し行うことで，エージェント
は環境に対して良い報酬を受け取りやすい行動が取
れるようになる．強化学習をプログラム合成に適用
するためには，行動，状態，報酬を定義する必要があ
る．文献[32] では，以下のように定義している．
• 行動：コードの挿入.
• 状態：仕様と合成途中のプログラムの実行結果.
• 報酬：仕様を満たすプログラムが合成できたら
報酬を与える.
このように定義することで，合成途中のプログラムの
実行結果を見ながら，仕様を満たすためにはどのよう
にコードを合成していけばよいか学習することがで
きる．
一方，6. 1. 1 項で紹介した文献[23][149] も合成途中
Vol. 40
No. 2
May 2023
111
のプログラムの実行結果を見ながら次の行動を決め
る手法であった．文献[19] では強化学習をプログラ
ム合成に用いる利点について，1 つの仕様に対し様々
なパターンのプログラムを学習できることだと主張
している．プログラム合成の場合，多くのケースにお
いて仕様とプログラムは1 対1 ではなく1 対多の関
係である．例えば「入力変数に2 をかけて1 を足し
た値を返す」プログラムを作りたい場合，λx:2*x+1，
λx:x*2+1，λx:1+x*2，λx:1+2*x など，様々なパター
ンが考えられる．文献[23][149] や6. 1. 2 項で紹介し
たSeq2Seq 等の手法は正解データを用意して学習す
る教師あり学習だが，強化学習では明確な正解データ
を用意せず，報酬で評価する．1 つの仕様に対して網
羅的なプログラムのパターンの学習データを用意する
ことは困難であり，教師あり学習の場合，上記の例の
4 パターンのうち1 パターンしか学習データが用意で
きなかった際に，他の3 パターンは仕様を満たすにも
関わらず不正解なプログラムとして学習されてしま
う．一方で強化学習の場合は，正解データの用意は不
要であり，合成されたプログラムが仕様を満たすかど
うかさえ判定できれば良い．このように1 つの仕様
に対し，様々なパターンのプログラムを学習できるこ
とが強化学習をプログラム合成に用いる利点である．
このような利点もあり，入力プログラムとその解析
木のペアから文脈自由文法のパーサーを合成すると
いった困難なタスクに強化学習を用いたプログラム
合成を適用する研究も存在する[22]．
6. 1. 5
学習データや学習方法の工夫
ここまで確率モデルを用いた様々な手法を紹介し
てきたが，その多くで深層学習モデルが使用されてい
る．それらの学習精度を向上させるため，学習用の
データセットに着目した研究も存在する[7][93][114]．
深層学習モデルを用いたプログラム合成では，DSL
から無作為にコンポーネントを組み合わせて生成し
たプログラムを学習用データセットとして用いるこ
とが多い[6]．その場合，プログラムはある特徴にお
いて分布に差が生じると考えられる．特徴とは例え
ばプログラムを構成するコンポーネント数などであ
る．文献[114] では，そういった特徴に対して均等な
データセットを用意することで，学習精度を向上させ
ている．また文献[93] では，入出力に関する仕様情
報を追加することで，学習精度を向上させている．例
えば，「入力リストは出力リストと同じ長さか？」と
いった情報である．文献[7] では，ボトムアップ探索
において，合成中に得られたプログラムを学習に用い
ることで，事前学習なしに大幅な性能向上を達成して
いる．これらの工夫は深層学習モデルを用いた様々
なプログラム合成手法に適用することができるため，
非常に有益である．
6. 1. 6
ヒューリスティック探索
ヒューリスティック探索では，3. 3. 4 項で述べたよ
うに人間の経験則に基づいた探索ルールを評価関数
で書き下し，その評価関数に基づいて探索を行う．確
率モデルを用いたプログラム合成では機械学習等を
用いて自動でモデルを導出していたのに対し，ヒュー
リスティック探索では人間の経験則に基づいた探索
ルールを評価関数等で書き下す．ヒューリスティッ
ク探索は評価関数の設計次第では様々な要件のプロ
グラム(実行速度が速い，使用するメモリが少ない等)
を探索することができ，また実装も容易であることか
ら様々なドメインに適用できる．
文献[111] では，仕様として与えられた入出力例が
複数個存在するケースにおいて，入出力例の一部が通
過するプログラムは入出力例がすべて通過するプロ
グラムの一部を含むという経験則を用いている．入
出力例の一部が通過するプログラムが得られた場合，
そのプログラムをひな形として他の入出力例も満た
すように合成を行っている．
一方ヒューリスティック探索においては，局所最
適解に陥ることがあり，その場合最適解に辿り着く
ことが困難であるという課題が指摘されている[109]．
(ただしこの課題はプログラム合成に限らず一般的な
ヒューリスティック探索の課題である．) 例えば評価
関数が図10 のような値で変化するとする．評価関数
は値が大きいほど所望のプログラムに近いと定義さ
れており，大域的最適解の値をとった時，所望のプロ
グラムが得られるとする．探索中に局所最適解にた
どり着いた際，その後の探索において左右どちらに
移動しても評価関数の値が悪くなってしまう．した
がって局所最適解にとどまり続けることになり，大域
112
コンピュータソフトウェア
図10
ヒューリスティック探索における局所最適解
的最適解にたどり着かない．
このような課題を解決するため，文献[109] では，
ヒューリスティック探索において，遅延評価法を用い
ている．遅延評価法は評価関数の値をすぐに受け入れ
るのではなく，一定の間，探索をし続け，その間に見
つかったベストな評価関数の値を受け入れることで
局所最適解に陥りにくくする手法である．それによ
り，ループを含むプログラム等のこれまでに合成する
ことが難しかったプログラムの合成に成功している．
6. 2
探索空間の枝刈り
本節では探索空間を枝刈りする2 つの方法を紹介
する．
6. 2. 1
制約解消法による枝刈り
制約解消法による枝刈りとは，3. 3. 3 項で紹介した
ようにプログラム合成問題を制約に変換し，SMT ソ
ルバ等の制約ソルバを用いて制約を解くことで所望の
プログラムを得る手法である．制約解消法の多くが，
スケッチの穴を埋めるために用いられている．
JLibSketch [80] はスケッチ手法において，ライブ
ラリを使用したプログラムの合成を実現する技術で
ある．ライブラリの関数は複雑な場合が多くまたネ
イティブコードを含んでいる可能性もあり，従来の制
約解消法を用いたスケッチ手法に組み込むことは困
難であった．JLibSketch はライブラリの仕様をユー
ザが記述できるようにすることで制約に落とし込む
ことを可能にし，ライブラリの関数を用いたプログラ
ム合成を実現している．
また専門的な領域への適用も存在する．Swizzle
Inventor [97] ではGPU を使用するプログラムにおい
て，ユーザが作成したスケッチからGPU を効率的に
駆動するプログラムを自動生成している．
制約解消法は6. 1. 3 項で紹介した雛形生成に基づ
いた探索とも相性が良い．文献[21][24][36] では，自
動生成されたスケッチの穴を埋めるために制約解消
法を用いている．
6. 2. 2
演繹的手法による枝刈り
演繹的手法による枝刈りとは，3. 3. 2 項で紹介した
ように仕様を分割することで探索を効率化する手法
である．
EUSolver [4] では分岐を持つプログラムの合成に
おいて，分岐条件と分岐先をそれぞれ独立して合成す
ることで効率化している．例えば与えられた2 つの
引数x,y のうち大きい値を返すmax 関数を合成する
問題を考える．入出力例として，1, 0 →1，2, 0 →2，
0, 2 →2 が与えられているとする．EUSolver は初
めに，各入出力例を満たすプログラムを合成する．
1, 0 →1，2, 0 →2 を満たすプログラムはx，0, 2 →2
を満たすプログラムはy となる．続いて分岐の条件を
生成する．上記のプログラムを振り分ける条件はx >
y となる．最後にこれらのプログラムを結合して，if
x > y then x else y が得られる．EUSolver では
このように問題を分割して合成することで効率化に
成功しており，2016 年のSyGuS のコンペティショ
ン(3. 2. 2 項参照) のGeneral Track 及びPBE Track
で優勝している．
演繹的推論の結果を学習することで効率化する手
法も存在する．文献[35] では，演繹的に仕様を満た
さないと判定されたプログラムに対してその原因を
特定し，同様のプログラムを探索から除外することで
大幅な効率化を実現している．文献[25] は演繹的推
論と強化学習を組み合わせている．具体的には，演繹
的に仕様を満たさないと判定されたプログラムを学
習することで，以降の探索で同様のプログラムの生成
を防ぎ，探索を効率化している．
型情報を活用して演繹的推論を行うこともできる．
通常，DSL を設計する際は，図3 のように型の制約
を考慮して文法の設計を行い，その文法に沿ったプロ
Vol. 40
No. 2
May 2023
113
グラムを生成するため，型を満たさないプログラムが
生成されることはない．しかし各コンポーネントに対
し，より詳細な入出力の型のルールを設定することで，
さらなる枝刈りを行うことができる．Synquid [98] は
篩型を用いたプログラム合成ツールである．篩型[63]
では，型に対してその型が表現する値の範囲を制限す
ることができる．例えば常に正の値を返すようなint
型であれば，x > 0 等の条件を加えることができる．
このように型情報も枝刈りに有効に活用することが
でき，データサイエンティスト向けのデータ変換プロ
グラム等の実用的な合成にも利用されている[36]．
3. 3. 2 項で述べた通り，演繹的手法を用いるために
は関数の仕様を人手で設計する必要がある．しかし
適切な仕様を設計するためには専門的な知識が求め
られるという欠点が存在する．ATLAS [132] では関
数の仕様の設計を自動で行うことができる．具体的
には事前に与えられたプログラム合成問題に対して
正しい解を返すまで関数の仕様を修正することで，最
終的に適切な仕様を生成する．
6. 3
グラフを用いた探索
6. 1 節と6. 2 節では，様々なプログラムを列挙する
ことで仕様を満たすプログラムを探す手法を紹介して
きた．しかし3. 3. 5 項で説明したように，候補プロ
グラムの数が膨大な場合はプログラムの集合をコン
パクトな形で保持することが求められる．本項では，
プログラムの集合を簡潔なグラフで表し，そのグラフ
に基づいて探索を行う手法を紹介する．
6. 3. 1
VSA を用いた探索
VSA を用いた探索とは，3. 3. 5 項で説明したように
バージョン空間代数(VSA) を用いてプログラムの集
合をコンパクトに表現しつつ，探索を行う手法である．
今回の調査でも入出力例を用いたプログラム合成のよ
うに候補プログラムが膨大に存在する場合に用いられ
ていた．例えば入出力例から正規表現を合成する技術
であるFlashProﬁle [94] や，表形式データのフィルタ
リングを行うプログラムを合成するFIDEX [135] な
どである．なおFlashProﬁle は3. 3. 5 項で紹介した
VSA を用いたプログラム合成の汎用フレームワーク
であるFlashMeta を拡張することで実現している．
6. 3. 2
FTA を用いた探索
プログラムの集合をコンパクトに表現する他の方法
として，有限木オートマトン(Finite Tree Automa-
ton，以下FTA) が存在する．文献[133] を参考に，
FTA を用いたプログラムの集合の表現を図11 に示
す．ただしx は入力とする．今，入出力例1 →9 を
満たすプログラムを合成したいとする．図11 のDSL
で合成されるプログラムはx+2，x+3，(x+2)*2 など
無数に存在するが，同じ値を返す式は同じノードに到
達するようにすることで図11 のグラフのようにコン
パクトに表現できる．例えば入力が1 の時，x+3 と
(x+2)*2 は4 という同じ値を返すため，4 というノー
ドにまとめることができる．これは3. 3. 1 項で紹介
したボトムアップ探索における観測的等価性と同じ
考え方であり，実際にボトムアップ探索中に得られる
プログラムの集合のコンパクトな表現として使われ
ている[134]．
文献[51] では，入出力例にノイズが存在する場合，
つまり入出力例を全て満たすプログラムが存在する可
能性が低い場合のプログラム合成において，FTA に
入出力例の満足度やプログラムの複雑度等を評価し
た重みを導入することで，効率的な探索を可能として
いる．文献[133] はFTA を抽象化することでよりコ
ンパクトな表現を可能にし，探索空間を狭めている．
抽象化とはノードを出力ではなく出力の範囲でまと
めることを指す．例えばノードが2, 3 と2 つ存在し
た場合，2 ≤n ≤3 とすることで1 つに統一でき，よ
りコンパクトな表現が可能になる．
6. 3. 3
TTN を用いた探索
型遷移モデル(Type Transition Nets，以下TTN)
では，ノードを型，エッジをコンポーネントとしてグ
ラフを構築する．ノードを型として表現することで，
プログラムの集合のよりコンパクトな表現が可能で
ある．
SyPet [37] では数千のコンポーネントの候補がある
プログラム合成について，TTN を用いることで実現
している．コンポーネントの候補が数千もある場合，
候補プログラムの数は膨大となる．そこでSyPet で
は初めにコンポーネントの型遷移のグラフをTTN と
して構築することで，プログラムの集合をコンパクト
114
コンピュータソフトウェア
図11
FTA によるプログラム合成
に表現する．続いて仕様(シグネチャと入出力例) を
満たしうる型の遷移を抽出し，その遷移からプログラ
ムのスケッチを生成する．最後に3. 3. 3 項で紹介し
た制約解消法を用いてスケッチの穴を埋めることで，
仕様を満たすプログラムを出力する．
このようにTTN を用いることでコンポーネント
の候補が多い場合でも合成が可能であり，Haskell の
API の自動合成などにも用いられている[61]．
6. 4
仕様情報を追加しながら合成
「仕様情報を追加しながら合成」とは，少量の仕様
情報から合成を開始し，その後不足している仕様情報
を補いながら合成を行う手法である．本節では2 つ
の方法を紹介する．
6. 4. 1
反例駆動型帰納的合成(CEGIS)
反例駆動型帰納的合成(Counterexample-guided
inductive synthesis，以下CEGIS) とは，3. 3. 3 項で
紹介したように，合成と検証を繰り返すことでプロ
グラム合成を行う方法である．文献[148] では深層強
化学習モデルの安全性保証のためにCEGIS によるプ
ログラム合成が用いられている．深層強化学習で使
用されるニューラルネットワークは一般的にブラッ
クボックスであり，安全性を保証することが難しい．
そこで学習済みのニューラルネットワークと類似し
た動作をするプログラムを合成し，そのプログラムを
CEGIS によって安全条件を満たすまで修正すること
で，最終的に学習済みニューラルネットワークと類似
した動作をしつつ，安全性が保証されたプログラムが
合成できる．
CEGIS では効率的に合成を行うために，多くのプ
ログラム候補を枝刈りできるような反例を生成する
ことが重要である．文献[102] では，そのような反例
を深層学習モデルによって学習することで，合成を効
率化している．
6. 4. 2
対話型プログラム合成
対話型プログラム合成は，一度にプログラムを完成
させるのではなく，プログラム合成とユーザによる結
果確認，情報の追加を繰り返すことでプログラムを
徐々に完成させていく手法である．
文献[96] では合成されたプログラムに対し，足りな
い部分プログラムを追加していくことでプログラムを
完成させていく．一方，プログラム本体のレビューは
ユーザにとっては負担となる場合もある．文献[42][64]
では，ユーザがプログラムを確認する際に合成したプ
ログラムの入出力例を提示することで，ユーザにとっ
てよりわかりやすい形でのレビューを実現している．
7
調査結果4：プログラム合成をどのドメイ
ンに適用するか？
調査結果4 を表4 に示し，以下に詳細を説明する．
7. 1
プログラマの支援
プログラム合成の最も主要な適用先は，プログラマ
の支援である．日々多くのプログラムを記述してい
るプログラマにとって，自動でプログラムを生成でき
るプログラム合成は非常に有益な技術となりうる．
文献[61] では，Haskell 向けのプログラム合成
ツールとしてHoogle+†8 をWeb 上に公開してい
る．Hoogle+は，入出力例，型のどちらか，もしくは
その両方を入力として使えるようにしている．また，
合成後は合成されたプログラムの入出力例を提示す
ることで，ユーザにどのようなプログラムが生成でき
たのかわかりやすく伝えている．
このように一部で有用なツールも見られるが，現在
のプログラム合成技術は必ずしも複雑なプログラム
†8
https://hoogleplus.goto.ucsd.edu/
Vol. 40
No. 2
May 2023
115
表4
プログラム合成の適用ドメインと年ごとの論文数の推移
年数
2016
2017
2018
2019
2020
合計
プログラマの支援
3
5
3
7
5
23
日常的なタスクの自動化
2
0
0
1
1
4
データ変換
3
5
1
0
3
12
ビジュアル情報のプログラム化
0
0
0
3
3
6
深層学習モデルのホワイトボックス化
0
0
0
2
1
3
　
プログラマの支援：[9][18][20][21][37][42][49][59][61][68][77][80][81][88][94][96][97][111][115][118][119]
日常的なタスクの自動化：[30][75][85][122]
データ変換：[36][38][46][58][107][117][130][131][134][135][140][141]
ビジュアル情報のプログラム化：[55][70][72][76][127][145]
深層学習モデルのホワイトボックス化：[60][105][148]
を生成できるわけではなく，また単純なプログラム
であればプログラマが書いた方が速いといった課題
が存在する．このような理由もあり，プログラマの
支援を目指した研究では，仕様情報だけでなくプロ
グラマの知見も与えることで実用的なプログラムの
生成を実現した研究が多く見受けられる．例えば文
献[37][49][88][111] では，ユーザが仕様だけでなく使
用される可能性のあるメソッドやAPI を与えること
で，プログラマが所望するプログラムの生成に柔軟に
対応できる．また文献[80][97] では仕様だけでなくス
ケッチをユーザが与えている．通常，プログラマがプ
ログラムを書く際は使用するライブラリやAPI，そ
してプログラムの構造にある程度目星がついている
場合が多いと思われるため，仕様だけでなくAPI や
スケッチを与えることは現実的である．
また6. 4. 2 項で紹介した対話型プログラム合成も
プログラマの支援として有望なアプローチの1 つで
ある．多くのプログラマはプログラムを書く時，一度
に大量のコードを書き上げるのではなく，小刻みに動
作確認を繰り返しながらプログラムを生成していく．
したがって徐々にプログラムを作り上げる対話型プ
ログラム合成は現在のプログラミングスタイルにも
フィットしている．
その他，分散システム[52][118] や，ネットワーク
プログラム[81]，確率的プログラム[20]，ロボットの
制御プログラム[42] など，専門的な領域へのプログ
ラム合成の適用も見られた．
7. 2
日常的なタスクの自動化
ドキュメント編集やPC 上でのクリック等のデバ
イス操作など，エンドユーザが日常的に行うような作
業をプログラム合成によって自動化する研究も存在
する．
文献[85] では，ドキュメント編集等の編集履歴か
ら過去の編集を自動化するプログラムを生成すること
で，繰り返し行われる編集を自動化するBlue-Pencil
と呼ばれるツールを開発している．Blue-Pencil は
ユーザが明示的に仕様を与える必要がなく，編集操作
から自動で学習するため，エンドユーザにとって非常
に使いやすい技術となっている．
文献[30][75] では，自然言語からテキスト編集等の
簡単なプログラムの生成を実現している．文献[122]
では，自然言語とユーザの操作からメールの転送，航
空券の予約等の繰り返し行われるようなタスクを自
動化している．自然言語は入出力例よりも直感的で
あり，エンドユーザを対象としたドメインでは有効な
仕様形式である．
116
コンピュータソフトウェア
7. 3
データ変換
何らかの形式のデータを別のデータへと変換する
タスクは，あらゆるユーザが直面したことがあるだろ
う．例えばデータサイエンティストであればデータ
分析用のフォーマットへの変換，エンドユーザであれ
ばExcel の編集等である．データ変換を行うために
は，変換用プログラムを記述したり，人手で1 つ1 つ
変換を行ったりするため，多くの工数がかかる．変換
前後の入出力例を与えるだけで変換プログラムを自
動生成できるプログラム合成は，このタスクと相性が
非常に良く，様々な研究が存在する．
例えば文献[135] ではデータのフィルタリング，
文献[140] では木構造のデータ変換，文献[130][141]
はSQL 文の合成，文献[134] ではデータ補完，文
献[117] では日付や時間等のデータフォーマットの統
一を行うためにプログラム合成を用いている．また文
献[46][58][107] ではweb 上のデータから所望のデー
タを取得する，web スクレイピングを行うプログラ
ムを自動生成している．インターネットが急速に普
及しweb 上に多量の情報が溢れる現在社会において
は，web 上から所望の情報のみを抽出する技術の需要
は大きいと考えられる．特に文献[46][107] では，4. 1
節で紹介したように入力例のみからプログラムが生
成できるため，ユーザにとって非常に負担が少ない技
術となっており，有望である．
7. 4
ビジュアル情報のプログラム化
画像や動画等のビジュアル情報のプログラム化の
ためにもプログラム合成は有用である．文献[12][70]
では，スマートフォンアプリ等のUI デザインから，
画面を表すプログラムの自動生成を行っている．そ
れにより，UI デザイナーがデザインした画像を直接
プログラムへと落とし込むことを可能にしている．
文献[27][33][55][72][76][145] では，画像からオブジェ
クトを識別するプログラムを自動生成している．画
像認識は深層学習が強い分野ではあるが，ブラック
ボックスのニューラルネットワークモデルと異なり，
ホワイトボックスであるプログラムとして表現するこ
とで，ユーザの理解，編集等を容易にできる利点があ
る．また画像だけでなく文献[123] は動画，[90][127]
は3D モデルを対象としている．
7. 5
深層学習モデルのホワイトボックス化
深層学習モデルは機械学習の性能を向上させるこ
とに成功したが，無数のニューロンが組み合わさった
非常に複雑な構造となっているためブラックボック
ス化されており，予測の根拠を知ることは困難であ
る．品質の保証の難しさが深層学習を用いたアプリ
ケーションの普及を妨げていることが指摘されてお
り[148]，プログラム合成によるホワイトボックス化
の研究が行われている．
文献[148] では，深層学習モデルと近似的な動作を
するプログラムをプログラム合成によって生成する
ことで，形式的検証による信頼性の高い品質保証を可
能にしている．文献[60] では，学習データが十分得
られない場合の機械学習において，少量のデータセッ
トからの学習をプログラム合成によって実現してい
る．具体的には，少量の学習データから学習した深層
学習モデルと近似的な動作をするプログラムをプロ
グラム合成によって生成する．続いてユーザがその
プログラムを確認し，学習が不十分な箇所を補うよう
なデータセットを追加して再度学習するといった作
業を繰り返すことでより精度の高い深層学習モデル
の生成を可能としている．
8
考察
8. 1
調査結果1：ユーザの意図をどのような形式
で与えるか？
表1 の通り，入出力例を用いる場合が最も多かっ
た．理由としては入出力例がユーザにとって作成し
やすく，またシステムにとっても解釈がしやすいため
だと考えられる．これは形式仕様や自然言語にはな
い特徴であり，今後も入出力例が主要な形式であり続
ける可能性は高い．
一方で入出力例の欠点として情報量が少なく，ユー
ザの意図が伝えにくいことが挙げられる．将来的に
はより複雑なプログラムを生成するために，形式仕様
や自然言語といった情報と合わせて仕様を表現する
ようになる可能性がある．特に自然言語はユーザに
とって最も簡単に意図を表すことができる形式であ
Vol. 40
No. 2
May 2023
117
り入出力例と相性が良く，今回の調査でも組み合わせ
て使用している研究が存在した[21][24][42]．
次に多かった形式は形式仕様である．形式仕様は
作成にスキルが必要なものの，ユーザに意図を最も的
確に表すことができ，システムにとっても解釈がしや
すい．一定のスキルを持つプログラマの支援を目的
とした研究では，形式仕様は今後も使われ続けると考
えられる．
自然言語は今回の調査で最も少なかった．理由と
しては自然言語には曖昧性があり，システムによる解
釈が難しいことが原因だと考えられる．しかし一方
で研究自体は増加傾向にあり，これはSeq2Seq 等の
自然言語を扱うことが得意な深層学習モデルの登場
によるものだと考えられる．最近の深層学習の研究
では，ニューロン数を大幅に増やしたモデルで事前学
習を行い，その後，機械翻訳や質問応答等のタスクへ
転移学習(別のタスクで学習したモデルを関連する別
の領域の学習に適用させる学習方法) することで，精
度が向上することが報告されている[17]．このような
大規模モデルをプログラム合成のタスクに転移学習
することで，自然言語からより複雑なプログラムを生
成できるようになるかもしれない．
8. 2
調査結果2：プログラム空間をどう定義す
るか？
表2 の通り，事前に使用するコンポーネント集を定
義する方法が圧倒的に多かった．事前に使用するコ
ンポーネント集を定義することで探索空間を狭めら
れるだけでなく，演繹的な手法や確率モデルを用いた
手法が活用できるといったメリットがある．プログ
ラムの探索性能に限界がある現在では，そういったメ
リットは非常に重要であり，今後もプログラム合成は
特定のドメインで活躍する技術になると考えられる．
一方でコンポーネントの定義が不要な研究も見受
けられた．系列データ変換モデルを用いた場合は，学
習データから自動でコンポーネントの特性を学習で
きるためである．8. 1 節で紹介したように系列データ
変換モデルは大規模かつ高性能化しており，将来的に
はオンライン上のあらゆるプログラムを学習するこ
とで，特定のドメインに囚われないプログラム合成が
可能になるかもしれない．
8. 3
調査結果3：プログラム空間をどう探索す
るか？
表3 の通り，優先探索が最も多かった．理由とし
ては近年活発に研究が行われている深層学習の研究
成果がプログラム合成にも積極的に取り入れられた
ためであり，深層学習の研究が未だに活発に行われて
いることを考えると，今後もこの流れは続くのではな
いかと思われる．探索空間の枝刈りを目指した研究
やグラフを用いた探索については，増加傾向は見られ
ないものの，安定して論文が出続けている．
これらの手法は今後，それぞれの特徴を活かした異
なる領域で活躍していくだろう．優先探索の中でも学
習をベースとした手法では，過去のプログラムが大量
に存在する領域と相性が良い．例えばプログラマが
頻繁に記述するような関数はGitHub 上に大量に存
在するため，機械学習によるプログラム生成に適して
いるだろう．実際にGitHub Copilot†9 ではGitHub
上のプログラムを学習することで，メソッド名やコメ
ントからメソッドの中身を自動生成することを可能
としている．一方で演繹的推論を用いた手法は予め
決められた狭いドメインでの高速なプログラム生成
に適している．今後もエンドユーザが行うような軽
量な作業の自動化や，特定領域の専門的なプログラム
の生成などに用いられるだろう．
またこれらの手法は互いに干渉を起こすものでは
なく，基本的に組み合わせも可能である．実際に今回
の調査でも，演繹的手法による枝刈りと強化学習を組
み合わせた研究[25] や，グラフを用いた探索中に確
率モデルを用いて優先探索を行う研究[65][66] が存在
した．今後はより探索を効率化するために，組み合わ
せた研究も増えるのではないかと考えられる．
また対話型プログラム合成はプログラム合成を実用
化する上で重要なアイデアである．ユーザはシステ
ムに与えた仕様情報以外にも，作成したいプログラム
について様々な情報を持っている．例えばプログラ
マの場合，使用するコンポーネントや大まかなプログ
†9
https://copilot.github.com/
118
コンピュータソフトウェア
ラムの構成は，ある程度頭の中にある場合が多いと思
われる．そのような情報を生成されたプログラムを
確認しながら必要に応じて与えていくことで，より実
用的なプログラムの生成が可能となると考えられる．
8. 4
調査結果4：プログラム合成をどのドメイン
に適用するか？
表4 の通り，プログラマを支援する研究が最も多
かった．プログラマはプログラムを書く機会が最も
多いだけでなく，形式的な仕様を書くスキルがあった
り，合成されたプログラムの妥当性をレビューできる
という点において，プログラム合成を最も有効に使う
ことができる．今後は様々なドメインにおいて，プロ
グラム合成を用いたプログラマの支援技術が増えて
いくのではないかと考えられる．
データ変換に対してプログラム合成を用いた研究
も多く存在した．データ変換はデータサイエンティ
ストからExcel を操作する人まで多くの人が実施す
る作業であり，入出力例も作成しやすい．データ活用
が重要視される現代社会において，データを扱う機会
は今後増えていくことが予想されるため，プログラム
合成によるデータ変換の重要度は増していくかもし
れない．
ビジュアル情報のプログラム化や深層学習モデル
のホワイトボックス化は，プログラム合成の可能性を
広げる応用例である．既に存在する情報をプログラ
ム化することでユーザの理解や編集を容易にすると
いう考え方は，情報が溢れる現代社会において今後
様々な応用例が出てくるかもしれない．
8. 5
会議の分野ごとの傾向について
最後にプログラム合成の研究について，会議の分野
ごとの傾向を述べる．本論文では2. 2 節で述べた通
り，ソフトウェア工学分野(以下SE)，プログラミン
グ言語分野(以下PL)，人工知能分野(以下AI)，自
然言語処理分野(以下NL) の4 分野を調査対象とし
ている．各分野ごとの研究の傾向について，表5，6，
7，8 にまとめた．
表5 は各分野ごとのプログラム合成の論文数をま
とめた表である．表5 によるとプログラム合成の論
文は主にPL，AI 分野に掲載されている．また各分
野の1 会議ごとの平均のプログラム合成の論文数を
見るとPL，AI，NL 分野でほぼ同じ数が掲載されて
おり，様々な分野で注目されていることがわかる．一
方でSE 分野では掲載数が5 件と少なかった．しかし
調査論文を“program synthesis” 等のキーワードで
絞り込んだ時点(2. 2 節の手順2) では，SE 分野にお
いても31 件の論文が存在していた．これは今回の調
査対象外としたバグ自動修正などの分野でプログラ
ム合成が用いられているケースが存在したためであ
り[10][110]，プログラム合成という技術自体はSE 分
野にも浸透していると考えられる．SE 分野ではソフ
トウェア開発の効率化に向けて，実用化を目指した研
究が盛んに行われている．バグ自動修正等の領域で
プログラム合成の有効性が示されれば，今後SE 分野
においても仕様からプログラムを自動生成する研究
が増加し，プログラム合成のソフトウェア開発現場へ
の普及が加速するかもしれない．
表6 はプログラム合成の仕様の形式について，各
分野ごとの論文数をまとめた表である．PL 分野では
主に入出力例と形式仕様が使用されている．特に形
式仕様はほぼPL 分野でのみ使われており，これは制
約解消法や演繹的手法などのPL 分野が得意とする手
法と相性が良いためだと考えられる．AI 分野では主
に入出力例と自然言語が使用されている．これはAI
技術が入出力例や自然言語のような曖昧性の強い情
報を扱うことが他の技術と比較して得意なためだと
考えられる．NL 分野では当然ながらすべて自然言語
が使用されていた．
表7 はプログラム空間の定義方法について，各分野
ごとの論文数をまとめた表である．SE，PL，AI 分
野では事前に定義されたコンポーネントに基づいて
プログラム合成を行う研究が多いが，NL 分野はコン
ポーネントの定義が不要な研究が多い．これはNL 分
野では主に自然言語からプログラムへSeq2Seq 等の
系列データ変換モデルを用いて変換を行う研究が多
かったためだと考えられる．
表8 はプログラム空間の探索方法について，各分野
ごとの論文数をまとめた表である．SE，AI，NL 分
野ではほとんど優先探索が用いられている．これは
Vol. 40
No. 2
May 2023
119
表5
会議ごとのプログラム合成の論文数
会議の種類
SE
PL
AI
NL
全会議の合計論文数
5
62
47
8
1 会議あたりの平均論文数
2.5
8.9
7.8
8.0
表6
仕様の形式と会議ごとの論文数
会議の種類
SE
PL
AI
NL
入出力例
2
41
38
0
形式仕様
1
22
2
0
自然言語
3
3
7
8
表7
プログラム空間の定義方法と会議ごとの論文数
会議の種類
SE
PL
AI
NL
事前に使用するコンポーネント集を定義
5
57
42
1
合成の度にコンポーネント集をユーザが指定
0
5
1
0
コンポーネントの定義は不要
0
0
4
7
表8
プログラム空間の探索方法と会議ごとの論文数
会議の種類
SE
PL
AI
NL
優先探索
確率モデルによる探索のガイド
2
5
9
1
系列データ変換モデルによる探索
0
0
11
6
雛形生成によるプログラム合成
1
4
5
1
強化学習を用いたプログラム合成
0
1
7
0
学習データや学習方法の工夫
0
1
2
0
ヒューリスティック探索
0
8
8
0
合計
3
19
42
8
探索空間の
枝刈り
制約解消法による枝刈り
1
10
1
0
演繹的手法による枝刈り
0
19
1
0
合計
1
29
2
0
グラフを
用いた探索
VSA を用いた探索
0
6
1
0
FTA を用いた探索
1
3
0
0
TTN を用いた探索
0
3
0
0
合計
1
12
1
0
仕様情報を追加
しながら合成
CEGIS
1
9
1
0
対話型プログラム合成
0
4
2
0
合計
1
13
3
0
120
コンピュータソフトウェア
機械学習や自然言語処理技術等の，各分野が得意とす
る技術をプログラム合成へ適用したためだと考えら
れる．一方PL 分野は制約解消法や演繹的手法などの
PL 分野が得意とする手法だけでなく，他の手法も幅
広く使われていた．プログラム合成は主にPL 分野で
発展してきた技術であり，PL 分野では今も様々な角
度から研究が行われていることがわかる．
以上よりプログラム合成はSE 分野以外の各分野で
幅広く研究されていることがわかった．これは様々
な視点やアプローチによって研究が行われているこ
とを意味し，基礎技術の発展には引き続き期待ができ
る．今後はSE 分野にもプログラム合成の研究が広ま
れば，実用化に向けて大きく進展するかもしれない．
9
まとめ
仕様情報からプログラムを自動生成するプログラ
ム合成技術に関する調査を行った．ソフトウェア工
学，プログラミング言語，人工知能分野，自然言語処
理分野における主要会議の2016 年から2020 年まで
のフルペーパーの論文を対象とし，手法や適用ドメイ
ン等で分類した．本論文を読むことで，これまで整理
されていなかった最近5 年間のプログラム合成技術
の動向について，俯瞰的に知ることができる．
プログラミングは近年，スマートデバイスの普及や
プログラミングの義務教育化により，多くの人に広ま
ろうとしている．プログラム合成はそういった人々
を大きく支援しうる技術であり，今後の発展が期待さ
れる．現在，日本では海外と比べてプログラム合成に
取り組む研究者は著しく少ない．本論文が日本でプ
ログラム合成の研究が広まる1 つのきっかけとなれ
ば幸いである．
参考文献
[ 1 ]
Abate, A., David, C., Kesseli, P., Kroening,
D., and Polgreen, E.:
Counterexample guided in-
ductive synthesis modulo theories. in Hana Chock-
ler and Georg Weissenbacher, editors, Computer
Aided Veriﬁcation Springer International Publish-
ing, Cham, 2018, pp. 270–288.
[ 2 ]
Albarghouthi, A., Gulwani, S., and Kincaid,
Z.:
Recursive program synthesis.
in Sharygina,
N. and Veith, H. editors, Computer Aided Veriﬁca-
tion, Berlin, Heidelberg, Springer Berlin Heidelberg,
2013, pp. 934–950.
[ 3 ]
Alur, R., Bodik, R., Juniwal, G., Martin, M.
M. K., Raghothaman, M., Seshia, S. A., Singh,
R., Solar-Lezama, A., Torlak, E., and Udupa, A.:
Syntax-guided synthesis. in 2013 Formal Methods
in Computer-Aided Design, 2013, pp. 1–8.
[ 4 ]
Alur, R., Radhakrishna, A., and Udupa, A.:
Scaling enumerative program synthesis via divide
and conquer.
in Legay, A. and Margaria, T. edi-
tors, Tools and Algorithms for the Construction and
Analysis of Systems, Berlin, Heidelberg, Springer
Berlin Heidelberg, 2017, pp. 319–336.
[ 5 ]
An, S., Singh, R., Misailovic, S., and Samanta,
R.: Augmented example-based synthesis using rela-
tional perturbation properties, in Proc. ACM Pro-
gram. Lang., 4(POPL), December 2019.
[ 6 ]
Balog, M., Gaunt, A. L., Brockschmidt, M.,
Nowozin, S., and Tarlow, D.: Deepcoder: Learning
to write programs, in International Conference on
Learning Representations, 2017.
[ 7 ]
Barke, S., Peleg, H., and Polikarpova, N.: Just-
in-time learning for bottom-up enumerative synthe-
sis,
in Proc. ACM Program. Lang., 4(OOPSLA),
November 2020.
[ 8 ]
Barrett, C. W., Conway, C. L., Deters, M.,
Hadarean, L., Jovanovic, D., King, T., Reynolds,
A., and Tinelli, C.:
CVC4,
in Gopalakrishnan,
G. and Qadeer, S. editors, Computer Aided Veriﬁ-
cation - 23rd International Conference, CAV 2011,
Snowbird, UT, USA, July 14-20, 2011, Proceedings,
volume 6806 of Lecture Notes in Computer Science,
Springer, 2011, pp. 171–177.
[ 9 ]
Bavishi, R., Lemieux, C., Fox, R., Sen, K.,
and Stoica, I.: AutoPandas: Neural-backed genera-
tors for program synthesis. in Proc. ACM Program.
Lang., 3(OOPSLA), October 2019.
[ 10 ]
Bavishi, R., Yoshida, H., and Prasad, M. R.:
Phoenix:
Automated data-driven synthesis of re-
pairs for static analysis violations,
in Proceedings
of the 2019 27th ACM Joint Meeting on European
Software Engineering Conference and Symposium
on the Foundations of Software Engineering, ES-
EC/FSE 2019, New York, NY, USA, 2019. Associ-
ation for Computing Machinery, pp. 613–624.
[ 11 ]
Beyer, D., Henzinger, T. A., Majumdar, R.,
and Rybalchenko, A.: Invariant synthesis for com-
bined theories, in Cook, B.and Podelski, A.editors,
Veriﬁcation, Model Checking, and Abstract Inter-
pretation, Berlin, Heidelberg, 2007. Springer Berlin
Heidelberg, pp. 378–394.
[ 12 ]
Bielik, P., Fischer, M., and Vechev, M.:
Ro-
bust relational layout synthesis from examples for
Android, in Proc. ACM Program. Lang., 2(OOP-
SLA), October 2018.
[ 13 ]
Bielik, P., Raychev, V., and Vechev, M.: Pro-
gram synthesis for character level language model-
ing, in International Conference on Learning Rep-
Vol. 40
No. 2
May 2023
121
resentations, 2017.
[ 14 ]
Bloem, R., Chatterjee, K., and Jobstmann, B.:
Graph Games and Reactive Synthesis, Springer In-
ternational Publishing, Cham, 2018, pp. 921–962.
[ 15 ]
Bornholt, J. and Torlak, E.:
Synthesizing
memory models from framework sketches and lit-
mus tests,
in Proceedings of the 38th ACM SIG-
PLAN Conference on Programming Language De-
sign and Implementation, PLDI 2017, New York,
NY, USA, 2017. Association for Computing Machin-
ery, pp. 467–481.
[ 16 ]
Bornholt, J., Torlak, E., Grossman, D., and
Ceze, L.: Optimizing synthesis with metasketches,
in Proceedings of the 43rd Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming
Languages, POPL ’16, New York, NY, USA, 2016.
Association for Computing Machinery, pp. 775–788.
[ 17 ]
Brown, T., Mann, B., Ryder, N., Subbiah,
M., Kaplan, J. D., Dhariwal, P., Neelakantan, A.,
Shyam, P., Sastry, G., Askell, A., Agarwal, S.,
Herbert-Voss, A., Krueger, G., Henighan, T., Child,
R., Ramesh, A., Ziegler, D., Wu, J., Winter, C.,
Hesse, C., Chen, M., Sigler, E., Litwin, M., Gray,
S., Chess, B., Clark, J., Berner, C., McCandlish, S.,
Radford, A., Sutskever, I., and Amodei, D.:
Lan-
guage models are few-shot learners. in Larochelle,
H., Ranzato, M., Hadsell, R., Balcan, M. F., and
Lin, H. editors, Advances in Neural Information
Processing Systems, Volume 33, Curran Associates,
Inc., 2020, pp. 1877–1901.
[ 18 ]
Bshouty, N. H., Drachsler-Cohen, D., Vechev,
M., and Yahav, E.: Learning disjunctions of predi-
cates, in Kale, S. and Shamir, O. editors, Proceed-
ings of the 2017 Conference on Learning Theory,
Volume 65 of Proceedings of Machine Learning Re-
search, PMLR, 07–10 Jul 2017, pp. 346–369.
[ 19 ]
Bunel, R., Hausknecht, M., Devlin, J., Singh,
R., and Kohli, P.:
Leveraging grammar and rein-
forcement learning for neural program synthesis, in
International Conference on Learning Representa-
tions, 2018.
[ 20 ]
Chasins, S. and Phothilimthana, P. M.: Data-
driven synthesis of full probabilistic programs.
in
Majumdar, R. and Kunˇcak, V. editors, Computer
Aided Veriﬁcation, Cham, 2017. Springer Interna-
tional Publishing, pp. 279–304.
[ 21 ]
Chen, Q., Wang, X., Ye, X, Durrett, G., and
Dillig, I.:
Multi-modal synthesis of regular ex-
pressions.
in Proceedings of the 41st ACM SIG-
PLAN Conference on Programming Language De-
sign and Implementation, PLDI 2020, New York,
NY, USA, 2020. Association for Computing Machin-
ery, pp. 487–502.
[ 22 ]
Chen, X., Liu, C., and Song, D.: Towards syn-
thesizing complex programs from input-output ex-
amples.
in International Conference on Learning
Representations, 2018.
[ 23 ]
Chen, X., Liu, C., and Song, D.:
Execution-
guided neural program synthesis, in International
Conference on Learning Representations, 2019.
[ 24 ]
Chen, Y., Martins, R., and Feng, Y.: Maximal
multi-layer speciﬁcation synthesis.
in Proceedings
of the 2019 27th ACM Joint Meeting on European
Software Engineering Conference and Symposium
on the Foundations of Software Engineering, ES-
EC/FSE 2019, New York, NY, USA, 2019, Associ-
ation for Computing Machinery, pp. 602–612.
[ 25 ]
Chen, Y., Wang, C., Bastani, O., Dillig, I.,
and Feng, Y.: Program synthesis using deduction-
guided reinforcement learning.
in Lahiri, S. K.
and Wang, C. editors, Computer Aided Veriﬁca-
tion, Cham, 2020. Springer International Publish-
ing, pp. 587–610.
[ 26 ]
Christakopoulou, K. and Kalai, A.: Glass-box
program synthesis: A machine learning approach,
in AAAI, 2018.
[ 27 ]
Chugh, R., Hempel, B., Spradlin, M., and Al-
bers, J.:
Programmatic and direct manipulation,
together at last, in Proceedings of the 37th ACM
SIGPLAN Conference on Programming Language
Design and Implementation, PLDI ’16, New York,
NY, USA, 2016. Association for Computing Machin-
ery, pp. 341–354.
[ 28 ]
Cropper, A. and Dumanˇcic, S.: Learning large
logic programs by going beyond entailment.
in
Bessiere, C. editor, Proceedings of the Twenty-Ninth
International Joint Conference on Artiﬁcial Intel-
ligence, IJCAI-20, International Joint Conferences
on Artiﬁcial Intelligence Organization, 7 2020, Main
track, pp. 2073–2079.
[ 29 ]
Dang-Nhu, R.:
Plans:
Neuro-symbolic pro-
gram learning from videos. in Larochelle, H., Ran-
zato, M., Hadsell, R., Balcan, M. F., and Lin, H.
editors, Advances in Neural Information Process-
ing Systems, Volume 33, Curran Associates, Inc.,
2020, pp. 22445–22455.
[ 30 ]
Desai, A., Gulwani, S., Hingorani, V., Jain, N.,
Karkare, A., Marron, M., Sailesh, R., and Roy, S.:
Program synthesis using natural language, in Pro-
ceedings of the 38th International Conference on
Software Engineering, ICSE ’16, New York, NY,
USA, 2016, Association for Computing Machinery,
pp. 345–356.
[ 31 ]
Devlin, J., Uesato, J., Bhupatiraju, S., Singh,
R., Mohamed, A.-r., and Kohli, P.: Robustﬁll: Neu-
ral program learning under noisy I/O. in Proceed-
ings of the 34th International Conference on Ma-
chine Learning - Volume 70, ICML’17, JMLR.org,
2017, pp. 990–998.
[ 32 ]
Ellis, K., Nye, M., Pu, Y., Sosa, F., Tenen-
baum, J., and Solar-Lezama, A.:
Write, execute,
assess: Program synthesis with a REPL.
in Ad-
vances in Neural Information Processing Systems,
volume 32, Curran Associates, Inc., 2019.
[ 33 ]
Ellis, K., Ritchie, D., Solar-Lezama, A., and
Tenenbaum, J.: Learning to infer graphics programs
122
コンピュータソフトウェア
from hand-drawn images. in Bengio, S., Wallach,
H., Larochelle, H., Grauman, K., Cesa-Bianchi, N.,
and Garnett, R. editors, Advances in Neural Infor-
mation Processing Systems, volume 31, Curran As-
sociates, Inc., 2018.
[ 34 ]
Ellis, K., Solar-Lezama, A., and Tenenbaum,
J.: Sampling for bayesian program learning. in Lee,
D., Sugiyama, M., Luxburg, U., Guyon, I., and Gar-
nett, R. editors, Advances in Neural Information
Processing Systems, Volume 29, Curran Associates,
Inc., 2016.
[ 35 ]
Feng, Y., Martins, R., Bastani, O., and Dillig,
I.: Program synthesis using conﬂict-driven learning,
in Proceedings of the 39th ACM SIGPLAN Confer-
ence on Programming Language Design and Imple-
mentation, PLDI 2018, New York, NY, USA, 2018.
Association for Computing Machinery, pp. 420–435.
[ 36 ]
Feng, Y., Martins, R., Geﬀen, J. V., Dillig, I.,
and Chaudhuri, S.: Component-based synthesis of
table consolidation and transformation tasks from
examples.
in Proceedings of the 38th ACM SIG-
PLAN Conference on Programming Language De-
sign and Implementation, PLDI 2017, New York,
NY, USA, 2017. Association for Computing Machin-
ery, pp. 422–436.
[ 37 ]
Feng, Y., Martins, R., Wang, Y., Dillig, I., and
Reps, T. W.: Component-based synthesis for com-
plex APIs. in Proceedings of the 44th ACM SIG-
PLAN Symposium on Principles of Programming
Languages, POPL 2017, New York, NY, USA, 2017.
Association for Computing Machinery, pp. 599–612.
[ 38 ]
Feser, J., Madden, S., Tang, N., and Solar-
Lezama, A.:
Deductive optimization of relational
data storage.
in Proc. ACM Program. Lang.,
4(OOPSLA), November 2020.
[ 39 ]
Frankle, J., Osera, P.-M., Walker, D., and
Zdancewic, S.: Example-directed synthesis: A type-
theoretic interpretation, in Proceedings of the 43rd
Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, POPL ’16,
New York, NY, USA, 2016. Association for Com-
puting Machinery, pp. 802–815.
[ 40 ]
福地一斗, 福馬智生: 小特集：「AI トレンド・トッ
プカンファレンスNeurIPS 2018，AAAI 2019 報告
会」NeurIPS 概要・今年の傾向. 人工知能, 34(5) 2019,
pp. 686–688.
[ 41 ]
Gasc´on,
A.,
Tiwari,
A.,
Carmer,
B.,
and
Mathur, U.: Look for the proof to ﬁnd the program:
Decorated-component-based program synthesis. in
Majumdar, R. and Kunˇcak, V. editors, Computer
Aided Veriﬁcation, Cham, 2017. Springer Interna-
tional Publishing, pp. 86–103.
[ 42 ]
Gavran, I., Darulova, E., and Majumdar, R.:
Interactive synthesis of temporal speciﬁcations from
examples and natural language. in Proc. ACM Pro-
gram. Lang., 4(OOPSLA), November 2020.
[ 43 ]
Gazzola, L., Micucci, D., and Mariani, L.: Au-
tomatic software repair: A survey. IEEE Transac-
tions on Software Engineering, 45(1):34–67, 2019.
[ 44 ]
Goues, C. L., Nguyen, T. V., Forrest, S., and
Weimer, W.: Genprog: A generic method for auto-
matic software repair, IEEE Transactions on Soft-
ware Engineering, 38:54–72, 2012.
[ 45 ]
Gulwani, S.:
Automating string processing
in spreadsheets using input-output examples.
in
PoPL’11, January 26-28, 2011, Austin, Texas,
USA, January 2011.
[ 46 ]
Gulwani, S., Arjun, V. L., Radiˇcek, R. I., and
Raza, M.:
Structure interpretation of text for-
mats, in Proc. ACM Program, Lang., 4(OOPSLA),
November 2020.
[ 47 ]
Gulwani, S., and Marron, M.: Nlyze: Interac-
tive programming by natural language for spread-
sheet data analysis and manipulation, in Proceed-
ings of the 2014 ACM SIGMOD International Con-
ference on Management of Data, SIGMOD ’14, New
York, NY, USA, 2014, Association for Computing
Machinery, pp. 803–814.
[ 48 ]
Gulwani, S., Polozov, O., and Singh, R.: Pro-
gram synthesis. Foundations and Trends® in Pro-
gramming Languages, 2017, 4(1-2):1–119.
[ 49 ]
Guo, Z., James, M., Justo, D., Zhou, J., Wang,
Z., Jhala, R., and Polikarpova, N.: Program synthe-
sis by type-guided abstraction reﬁnement. in Proc.
ACM Program. Lang., 4(POPL), December 2019.
[ 50 ]
Gupta, K., Christensen, P. E., Chen, X., and
Song, D.: Synthesize, execute and debug: Learning
to repair for neural program synthesis. in Larochelle,
H., Ranzato, M., Hadsell, R., Balcan, M. F., and
Lin, H. editors, Advances in Neural Information
Processing Systems, Volume 33, Curran Associates,
Inc., 2020, pp. 17685–17695.
[ 51 ]
Handa, S. and Rinard, M. C.:
Inductive pro-
gram synthesis over noisy data, in Proceedings of the
28th ACM Joint Meeting on European Software En-
gineering Conference and Symposium on the Foun-
dations of Software Engineering, ESEC/FSE 2020,
New York, NY, USA, 2020. Association for Com-
puting Machinery, pp. 87–98.
[ 52 ]
Houshmand, F. and Lesani, M.:
Hamsaz:
Replication coordination analysis and synthesis, in
Proc. ACM Program. Lang., 3(POPL), January
2019.
[ 53 ]
Hu, Q., Cyphert, J., D’Antoni, L., and Reps,
T.: Exact and approximate methods for proving un-
realizability of syntax-guided synthesis problems. in
Proceedings of the 41st ACM SIGPLAN Conference
on Programming Language Design and Implemen-
tation, PLDI 2020, New York, NY, USA, 2020. As-
sociation for Computing Machinery, pp. 1128–1142.
[ 54 ]
Hu, Q. and D’Antoni, L.: Syntax-guided syn-
thesis with quantitative syntactic objectives.
in
Chockler, H. and Weissenbacher, G. editors, Com-
puter Aided Veriﬁcation, Cham, 2018. Springer In-
ternational Publishing, pp. 386–403.
[ 55 ]
Huang, J., Smith, C., Bastani, O., Singh, R.,
Vol. 40
No. 2
May 2023
123
Albarghouthi, A., and Naik, M.:
Generating pro-
grammatic referring expressions via program syn-
thesis. in Daum´e III, H. and Singh, A. editors, Pro-
ceedings of the 37th International Conference on
Machine Learning, Volume 119 of in Proceedings
of Machine Learning Research, PMLR, 13–18 Jul
2020, pp. 4495–4506.
[ 56 ]
Huang, K., Qiu, X., Shen, P., and Wang,
Y.:
Reconciling enumerative and deductive pro-
gram synthesis.
in Proceedings of the 41st ACM
SIGPLAN Conference on Programming Language
Design and Implementation, PLDI 2020, New York,
NY, USA, 2020, Association for Computing Ma-
chinery, pp. 1159–1174.
[ 57 ]
Inala, J. P., Polikarpova, N., Qiu, X., Lerner,
B. S., and Solar-Lezama, A.: Synthesis of recursive
ADT transformations from reusable templates, in
Legay, A. and Margaria, T. editors, Tools and Al-
gorithms for the Construction and Analysis of Sys-
tems, Berlin, Heidelberg, 2017. Springer Berlin Hei-
delberg, pp. 247–263.
[ 58 ]
Inala, J. P., and Singh, R.:
Webrelate: Inte-
grating web data with spreadsheets using examples,
in Proc. ACM Program. Lang., 2(POPL), December
2017.
[ 59 ]
Itzhaky,
S.,
Singh,
R.,
Solar-Lezama,
A.,
Yessenov, K., Lu, Y., Leiserson, C., and Chowdhury,
R.: Deriving divide-and-conquer dynamic program-
ming algorithms using solver-aided transformations,
in Proceedings of the 2016 ACM SIGPLAN Inter-
national Conference on Object-Oriented Program-
ming, Systems, Languages, and Applications, OOP-
SLA 2016, New York, NY, USA, 2016. Association
for Computing Machinery, pp. 145–164.
[ 60 ]
Iyer, A., Jonnalagedda, M., Parthasarathy, S.,
Radhakrishna, A., and Rajamani, S. K.: Synthesis
and machine learning for heterogeneous extraction.
in Proceedings of the 40th ACM SIGPLAN Confer-
ence on Programming Language Design and Imple-
mentation, PLDI 2019, New York, NY, USA, 2019.
Association for Computing Machinery, pp. 301–315.
[ 61 ]
James, M. B., Guo, Z., Wang, Z., Doshi, S., Pe-
leg, H., Jhala, R., and Polikarpova, N.: Digging for
fold: Synthesis-aided API discovery for Haskell. in
Proc. ACM Program. Lang., 4(OOPSLA), Novem-
ber 2020.
[ 62 ]
Jha, S., Gulwani, S., Seshia, S. A., and Tiwari,
A.:
Oracle-guided component-based program syn-
thesis.
in ICSE ’10, May 2-8 2010, Cape Town,
South Africa, May 2010.
[ 63 ]
Jhala, R., and Vazou, N.:
Reﬁnement types:
A tutorial. Foundations and Trends® in Program-
ming Languages, 6(3-4) 2021, pp. 159–317.
[ 64 ]
Ji, R., Liang, J., Xiong, Y., Zhang, L., and
Hu, Z.: Question selection for interactive program
synthesis.
in Proceedings of the 41st ACM SIG-
PLAN Conference on Programming Language De-
sign and Implementation, PLDI 2020, New York,
NY, USA, 2020. Association for Computing Machin-
ery, pp. 1143–1158.
[ 65 ]
Ji, R., Sun, Y., Xiong, Y., and Hu, Z.: Guid-
ing dynamic programing via structural probabil-
ity for accelerating programming by example.
in
Proc. ACM Program. Lang., 4(OOPSLA), Novem-
ber 2020.
[ 66 ]
Kalyan, A., Mohta, A., Polozov, O., Batra, D.,
Jain, P., and Gulwani, S.:
Neural-guided deduc-
tive search for real-time program synthesis from ex-
amples.
in International Conference on Learning
Representations, 2018.
[ 67 ]
Kneuss, E., Kuraj, I., Kuncak, V., and Suter,
P.:
Synthesis modulo recursive functions. in Pro-
ceedings of the 2013 ACM SIGPLAN International
Conference on Object Oriented Programming Sys-
tems Languages and Applications, OOPSLA ’13,
New York, NY, USA, 2013. Association for Com-
puting Machinery, pp. 407–426.
[ 68 ]
Knoth, T., Wang, D., Polikarpova, N., and
Hoﬀmann, J.: Resource-guided program synthesis.
in Proceedings of the 40th ACM SIGPLAN Confer-
ence on Programming Language Design and Imple-
mentation, PLDI 2019, New York, NY, USA, 2019.
Association for Computing Machinery, pp. 253–268.
[ 69 ]
Koza, J. R.: Genetic programming as a means
for programming computers by natural selection,
Statistics and Computing, 1994, 4:87–112.
[ 70 ]
Laich, L., Bielik, P., and Vechev, M.: Guiding
program synthesis by learning to generate examples.
in International Conference on Learning Represen-
tations, 2020.
[ 71 ]
Lee, W., Heo, K., Alur, R., and Naik, M.:
Accelerating search-based program synthesis using
learned probabilistic models. in Proceedings of the
39th ACM SIGPLAN Conference on Programming
Language Design and Implementation, PLDI 2018,
New York, NY, USA, 2018. Association for Com-
puting Machinery, pp. 436–449.
[ 72 ]
Li, Y., Mao, J., Zhang, X., Freeman, B., Tenen-
baum, J, Snavely, N., and Wu, J.: Multi-plane pro-
gram induction with 3D box priors. in Larochelle,
H., Ranzato, M., Hadsell, R., Balcan, M. F., and
Lin, H. editors, Advances in Neural Information
Processing Systems, Volume 33. Curran Associates,
Inc., 2020, pp. 7425–7436.
[ 73 ]
Liang,C., Norouzi, M., Berant, J., Le, Q. V.,
and Lao, N.: Memory augmented policy optimiza-
tion for program synthesis and semantic parsing, in
Bengio, S., Wallach, H., Larochelle, H., Grauman,
K., Cesa-Bianchi, N., and Garnett, R. editors, Ad-
vances in Neural Information Processing Systems,
Volume 31. Curran Associates, Inc., 2018.
[ 74 ]
Ling, W., Blunsom, P., Grefenstette, E., Her-
mann, K. M., Koˇcisk´y, T., Wang, F., and Senior, A.:
Latent predictor networks for code generation. in
Proceedings of the 54th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
124
コンピュータソフトウェア
Long Papers), Berlin, Germany, August 2016, Asso-
ciation for Computational Linguistics, pp. 599–609.
[ 75 ]
Liu, C., Chen, X., Shin, E. C., Chen, M., and
Song, D.: Latent attention for if-then program syn-
thesis. in NIPS, 2016.
[ 76 ]
Liu, Y., Wu, J., Wu, Z., Ritchie, D., Freeman,
W. T., and Tenenbaum, J. B.: Learning to describe
scenes with programs, in International Conference
on Learning Representations, 2019.
[ 77 ]
Loncaric, C., Ernst, M. D., and Torlak, E.:
Generalized data structure synthesis, in Proceedings
of the 40th International Conference on Software
Engineering, ICSE ’18, New York, NY, USA, 2018.
Association for Computing Machinery, pp. 958–968.
[ 78 ]
Lubin, J., Collins, N., Omar, C., and Chugh,
R.: Program sketching with live bidirectional eval-
uation.
in Proc. ACM Program. Lang., 4(ICFP),
August 2020.
[ 79 ]
Maina, S., Miltner, A., Fisher, K., Pierce, B.
C., Walker, D., and Zdancewic, S.:
Synthesizing
quotient lenses.
in Proc. ACM Program. Lang.,
2(ICFP), July 2018.
[ 80 ]
Mariano, B., Reese, J., Xu, S., Nguyen, T. V.,
Qiu, X., Foster, J. S., and Solar-Lezama, A.: Pro-
gram synthesis with algebraic library speciﬁcations.
in Proc. ACM Program. Lang., 3(OOPSLA), Octo-
ber 2019.
[ 81 ]
McClurg, J., Hojjat, H., and ˇCern´y, P.:
Syn-
chronization synthesis for network programs,
in
Majumdar, R. and Kunˇcak, V. editors, Computer
Aided Veriﬁcation, Cham, 2017, Springer Interna-
tional Publishing, pp. 301–321.
[ 82 ]
Menon, A. K., Tamuz, O., Gulwani, S., Lamp-
son, B., and Kalai, A. T.:
A machine learning
framework for programming by example. in Proceed-
ings of the 30th International Conference on Inter-
national Conference on Machine Learning - Volume
28, ICML’13, JMLR.org, 2013, pp. I–187–I–195.
[ 83 ]
Mens, T. and Tourw´e, T.: A survey of software
refactoring,
IEEE Trans. Softw. Eng., feb 2004,
30(2):126–139.
[ 84 ]
Miltner, A., Fisher, K., Pierce, B. C., Walker,
D., and Zdancewic, S.: Synthesizing bijective lenses,
in Proc. ACM Program. Lang., 2(POPL), December
2017.
[ 85 ]
Miltner, A., Gulwani, S., Le, V., Leung, A.,
Radhakrishna, A., Soares, G., Tiwari, A., and
Udupa, A.:
On the ﬂy synthesis of edit sugges-
tions. in Proc. ACM Program. Lang., 3(OOPSLA),
October 2019.
[ 86 ]
Miltner, A., Maina, S., Fisher, K, Pierce, B.
C., Walker, D., and Zdancewic, S.:
Synthesizing
symmetric lenses, in Proc. ACM Program. Lang.,
3(ICFP), July 2019.
[ 87 ]
Mollaysa, A., Paige, B., and Kalousis, A.:
Goal-directed generation of discrete structures with
conditional generative models.
in Larochelle, H.,
Ranzato, M., Hadsell, R., Balcan, M. F., and Lin, H.
editors, Advances in Neural Information Processing
Systems, Volume 33, Curran Associates, Inc., 2020.
pp. 21923–21933.
[ 88 ]
Murali, V., Qi, L., Chaudhuri, S., and Jer-
maine, C.:
Neural sketch learning for conditional
program generation.
in International Conference
on Learning Representations, 2018.
[ 89 ]
Nan, Z., Guan, H., and Shen, X.: Hisyn: Hu-
man learning-inspired natural language program-
ming. in Proceedings of the 28th ACM Joint Meet-
ing on European Software Engineering Conference
and Symposium on the Foundations of Software En-
gineering, ESEC/FSE 2020, New York, NY, USA,
2020, Association for Computing Machinery, pp. 75–
86.
[ 90 ]
Nandi, C., Wilcox, J. R., Panchekha, P., Blau,
T., Grossman, D., and Tatlock, Z.: Functional pro-
gramming for compiling and decompiling computer-
aided design,
in Proc. ACM Program. Lang.,
2(ICFP), July 2018.
[ 91 ]
Nye, M., Hewitt, L., Tenenbaum, J., and Solar-
Lezama, A.: Learning to infer program sketches. in
Chaudhuri, K. and Salakhutdinov, R. editors, Pro-
ceedings of the 36th International Conference on
Machine Learning, Volume 97 of Proceedings of Ma-
chine Learning Research, PMLR, 09–15 Jun 2019,
pp. 4861–4870.
[ 92 ]
Nye, M., Solar-Lezama, A., Tenenbaum, J.,
and Lake, B. M.: Learning compositional rules via
neural program synthesis. in Larochelle, H., Ran-
zato, M., Hadsell, R., Balcan, M. F., and Lin, H.
editors, Advances in Neural Information Process-
ing Systems, Volume 33, Curran Associates, Inc.,
2020, pp. 10832–10842.
[ 93 ]
Odena, A. and Sutton, C.: Learning to repre-
sent programs with property signatures. in Inter-
national Conference on Learning Representations,
2020.
[ 94 ]
Padhi, S., Jain, P., Perelman, D., Polozov, O.,
Gulwani, S., and Millstein, T.:
Flashproﬁle:
A
framework for synthesizing data proﬁles. in Proc.
ACM Program. Lang., 2(OOPSLA), October 2018.
[ 95 ]
Parisotto, E., Mohamed, A.-r., Singh, R., Li,
L., Zhou, D., and Kohli, P.:
Neuro-symbolic pro-
gram synthesis.
in International Conference on
Learning Representations, 2017.
[ 96 ]
Peleg, H., Gabay, R., Itzhaky, S., and Yahav,
E.:
Programming with a read-eval-synth loop, in
Proc. ACM Program. Lang., 4(OOPSLA), Novem-
ber 2020.
[ 97 ]
Phothilimthana, P. M., Elliott, A. S., Wang, A,
Jangda, A., Hagedorn, B., Barthels, H., Kaufman,
S. J., Grover, V., Torlak, E., and Bodik, R.: Swizzle
inventor: Data movement synthesis for GPU ker-
nels. in Proceedings of the Twenty-Fourth Interna-
tional Conference on Architectural Support for Pro-
gramming Languages and Operating Systems, ASP-
LOS ’19, New York, NY, USA, 2019. Association for
Vol. 40
No. 2
May 2023
125
Computing Machinery, pp 65–78.
[ 98 ]
Polikarpova, N., Kuraj, I., and Solar-Lezama,
A.: Program synthesis from polymorphic reﬁnement
types. SIGPLAN Not., June 2016, 51(6):522–538.
[ 99 ]
Polikarpova, N. and Sergey, I.: Structuring the
synthesis of heap-manipulating programs. in Proc.
ACM Program. Lang., 3(POPL), January 2019.
[100]
Polozov, O. and Gulwani, S.:
Flashmeta:
A framework for inductive program synthesis.
in
OOPSLA
2015
Proceedings
of
the
2015
ACM
SIGPLAN International Conference on Object-
Oriented Programming, Systems, Languages, and
Applications, October 2015, pp. 107–126.
[101]
Pu, Y., Ellis, K., Kryven, M., Tenenbaum, J.,
and Solar-Lezama, A.:
Program synthesis with
pragmatic communication. in Larochelle, H., Ran-
zato, M., Hadsell, R., Balcan, M. F., and Lin, H.
editors, Advances in Neural Information Process-
ing Systems, Volume 33, Curran Associates, Inc.,
2020, pp. 13249–13259.
[102]
Pu, Y., Miranda, Z., Solar-Lezama, A., and
Kaelbling, L.: Selecting representative examples for
program synthesis. in Dy, J. and Krause, A. edi-
tors, Proceedings of the 35th International Confer-
ence on Machine Learning, volume 80 of in Proceed-
ings of Machine Learning Research, PMLR, 10–15
Jul 2018, pp. 4161–4170.
[103]
Rabinovich, M., Stern, M., and Klein, D.: Ab-
stract syntax networks for code generation and se-
mantic parsing.
in Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), Vancouver,
Canada, July 2017. Association for Computational
Linguistics, pp. 1139–1149.
[104]
Raghothaman, M., Mendelson, J., Zhao, D.,
Naik, M., and Scholz, B.: Provenance-guided syn-
thesis of datalog programs. in Proc. ACM Program.
Lang., 4(POPL), December 2019.
[105]
Ramakrishnan, G., Lee, Y. C., and Albargh-
outhi, A.: Synthesizing action sequences for modi-
fying model decisions. in Proceedings of the AAAI
Conference on Artiﬁcial Intelligence, 34(04) Apr.
2020, pp. 5462–5469.
[106]
Raychev,
V.,
Bielik,
P.,
Vechev,
M.,
and
Krause, A.:
Learning programs from noisy data.
in Proceedings of the 43rd Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming
Languages, POPL ’16, New York, NY, USA, 2016.
Association for Computing Machinery, pp. 761–774.
[107]
Raza, M. and Gulwani, S.: Automated data ex-
traction using predictive program synthesis. in Pro-
ceedings of the Thirty-First AAAI Conference on
Artiﬁcial Intelligence, AAAI’17, AAAI Press, 2017,
pp. 882–890.
[108]
Raza, M. and Gulwani, S.:
Disjunctive pro-
gram synthesis: A robust approach to programming
by example, in AAAI 2018, Association for the Ad-
vancement of Artiﬁcial Intelligence, February 2018.
[109]
Rosin, C. D.: Stepping stones to inductive syn-
thesis of low-level looping programs. in Proceedings
of the AAAI Conference on Artiﬁcial Intelligence,
33(01) Jul. 2019, pp. 2362–2370.
[110]
Roy, S., Pandey, A., Dolan-Gavitt, B., and Hu,
Y.:
Bug synthesis: Challenging bug-ﬁnding tools
with deep faults. in Proceedings of the 2018 26th
ACM Joint Meeting on European Software Engi-
neering Conference and Symposium on the Foun-
dations of Software Engineering, ESEC/FSE 2018,
New York, NY, USA, 2018. Association for Com-
puting Machinery, pp. 224–234.
[111]
Shi, K., Steinhardt, J., and Liang, P.: Frangel:
Component-based synthesis with control structures.
in Proc. ACM Program. Lang., 3(POPL), January
2019.
[112]
Shin, E. C., Allamanis, M., Brockschmidt, M.,
and Polozov, A.:
Program synthesis and semantic
parsing with learned code idioms. in Advances in
Neural Information Processing Systems, Volume 32,
Curran Associates, Inc., 2019.
[113]
Shin, E. C., Polosukhin, I., and Song, D.: Im-
proving neural program synthesis with inferred exe-
cution traces. in Bengio, S., Wallach, H., Larochelle,
H., Grauman, K., Cesa-Bianchi, N., and Garnett, R.
editors, Advances in Neural Information Processing
Systems, Volume 31. Curran Associates, Inc., 2018.
[114]
Shin, R., Kant, N., Gupta, K., Bender, C., Tra-
bucco, B., Singh, R., and Song, D.:
Synthetic
datasets for neural program synthesis.
in Inter-
national Conference on Learning Representations,
2019.
[115]
Si, X., Raghothaman, M., Heo, K., and Naik,
M.:
Synthesizing datalog programs using numeri-
cal relaxation. in Proceedings of the Twenty-Eighth
International Joint Conference on Artiﬁcial In-
telligence, IJCAI-19, International Joint Confer-
ences on Artiﬁcial Intelligence Organization, 7 2019,
pp. 6117–6124.
[116]
Si, X., Yang, Y., Dai, H., Naik, M., and Song,
L.:
Learning a meta-solver for syntax-guided pro-
gram synthesis.
in International Conference on
Learning Representations, 2019.
[117]
Singh, R. and Gulwani, S.:
Transforming
spreadsheet data types using examples. in Proceed-
ings of the 43rd Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Lan-
guages, POPL ’16, New York, NY, USA, 2016. As-
sociation for Computing Machinery, pp. 343–356.
[118]
Smith, C. and Albarghouthi, A.:
Mapreduce
program synthesis. in Proceedings of the 37th ACM
SIGPLAN Conference on Programming Language
Design and Implementation, PLDI ’16, New York,
NY, USA, 2016. Association for Computing Machin-
ery, pp. 326–340.
[119]
Smith, C. and Albarghouthi, A.:
Synthesiz-
ing diﬀerentially private programs. in Proc. ACM
Program. Lang., 3(ICFP), July 2019.
126
コンピュータソフトウェア
[120]
Solar-Lezama,
A.:
Program Synthesis by
Sketching. PhD thesis, USA, 2008. AAI3353225.
[121]
Solar-Lezama, A., Jones, C. G., and Bodik, R.:
Sketching concurrent data structures.
SIGPLAN
Not., 43(6) jun 2008, pp. 136–148.
[122]
Srivastava, S., Polozov, O., Jojic, N., and
Meek, C.:
Learning web-based procedures by rea-
soning over explanations and demonstrations in con-
text.
in Proceedings of the 58th Annual Meeting
of the Association for Computational Linguistics,
Online, July 2020, Association for Computational
Linguistics, pp. 7652–7662.
[123]
Sun, S. -H., Noh, H., Somasundaram, S., and
Lim, J.:
Neural program synthesis from diverse
demonstration videos. in Dy, J. and Krause, A. ed-
itors, Proceedings of the 35th International Confer-
ence on Machine Learning, Volume 80 of in Proceed-
ings of Machine Learning Research, PMLR, 10–15
Jul 2018, pp. 4790–4799.
[124]
Sun, Z., Zhu, Q., Mou, L., Xiong, Y., Li, G.,
and Zhang, L.: A grammar-based structural CNN
decoder for code generation. in Proceedings of the
Thirty-Third AAAI Conference on Artiﬁcial In-
telligence and Thirty-First Innovative Applications
of Artiﬁcial Intelligence Conference and Ninth
AAAI Symposium on Educational Advances in
Artiﬁcial Intelligence, AAAI’19/IAAI’19/EAAI’19.
AAAI Press, 2019.
[125]
Sun, Z., Zhu, Q., Xiong, Y., Sun, Y., Mou, L.,
and Zhang, L.: Treegen: A tree-based transformer
architecture for code generation. in AAAI, 2020.
[126]
Sutskever, I., Vinyals, O., and Le, Q. V.:
Se-
quence to sequence learning with neural networks.
in Proceedings of the 27th International Conference
on Neural Information Processing Systems - Vol-
ume 2, NIPS’14, Cambridge, MA, USA, 2014. MIT
Press, pp. 3104–3112.
[127]
Tian, Y., Luo, A., Sun, X., Ellis, K., Freeman,
W. T., Tenenbaum, J. B., and Wu, J.:
Learning
to infer and execute 3D shape programs. in Inter-
national Conference on Learning Representations,
2019.
[128]
Valkov, L., Chaudhari, D., Srivastava, A., Sut-
ton, C., and Chaudhuri, S.: Houdini: Lifelong learn-
ing as program synthesis. in Bengio, S., Wallach, H.,
Larochelle, H., Grauman, K., Cesa-Bianchi, N., and
Garnett, R. editors, Advances in Neural Informa-
tion Processing Systems, Volume 31. Curran Asso-
ciates, Inc., 2018.
[129]
Vaswani, A., Shazeer, N., Parmar, N., Uszkor-
eit, J., Jones, Llion., Gomez, A. N., Kaiser, L., and
Polosukhin, I.: Attention is all you need. in Guyon,
I., Luxburg, U. V., Bengio, S., Wallach, H., Fergus,
R., Vishwanathan, S., and Garnett, R. editors, Ad-
vances in Neural Information Processing Systems,
Volume 30, Curran Associates, Inc., 2017.
[130]
Wang, C., Cheung, A., and Bodik, R.:
Syn-
thesizing highly expressive SQL queries from input-
output examples. in Proceedings of the 38th ACM
SIGPLAN Conference on Programming Language
Design and Implementation, PLDI 2017, New York,
NY, USA, 2017. Association for Computing Machin-
ery, pp. 452–466.
[131]
Wang, C., Feng, Y., Bodik, R., Cheung, A.,
and Dillig, I.:
Visualization by example, in Proc.
ACM Program. Lang., 4(POPL), December 2019.
[132]
Wang, X., Anderson, G., Dillig, I., and McMil-
lan, K. L.: Learning abstractions for program syn-
thesis. in Chockler, H. and Weissenbacher, G. ed-
itors, Computer Aided Veriﬁcation, Cham, 2018,
Springer International Publishing, pp. 407–426.
[133]
Wang, X., Dillig, I., and Singh, R.:
Program
synthesis using abstraction reﬁnement.
in Proc.
ACM Program. Lang., 2(POPL), December 2017.
[134]
Wang, X., Dillig, I., and Singh, R.: Synthesis of
data completion scripts using ﬁnite tree automata.
in Proc. ACM Program. Lang., 1(OOPSLA), Octo-
ber 2017.
[135]
Wang, X., Gulwani, S., and Singh, R.: Fidex:
Filtering spreadsheet data using examples. in Pro-
ceedings of the 2016 ACM SIGPLAN International
Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications, OOPSLA 2016,
New York, NY, USA, 2016, Association for Comput-
ing Machinery, pp. 195–213.
[136]
Wang, Y., Wang, X., and Dillig, I.: Relational
program synthesis. in Proc. ACM Program. Lang.,
2(OOPSLA), October 2018.
[137]
Wei, B., Li, G., Xia, X., Fu, Z., and Jin, Z.:
Code generation as a dual task of code summariza-
tion. in Advances in Neural Information Processing
Systems, Volume 32. Curran Associates, Inc., 2019.
[138]
Wolfman, S., Domingos, P., and Weld, D.: Pro-
gramming by demonstration using version space al-
gebra. Machine Learning, 53, 12 2001.
[139]
Xu, F. F., Jiang, Z., Yin, P., Vasilescu, B.,
and Neubig, G.: Incorporating external knowledge
through pre-training for natural language to code
generation. in Proceedings of the 58th Annual Meet-
ing of the Association for Computational Linguis-
tics, Online, July 2020, Association for Computa-
tional Linguistics, pp. 6045–6052.
[140]
Yaghmazadeh, N., Klinger, C., Dillig, I., and
Chaudhuri, S.: Synthesizing transformations on hi-
erarchically structured data. in Proceedings of the
37th ACM SIGPLAN Conference on Programming
Language Design and Implementation, PLDI ’16,
New York, NY, USA, 2016, Association for Com-
puting Machinery, pp. 508–521.
[141]
Yaghmazadeh, N., Wang, Y., Dillig, I., and Dil-
lig, T.: SQLizer: Query synthesis from natural lan-
guage. in Proc. ACM Program. Lang., 1(OOPSLA),
October 2017.
[142]
Ye, H., Li, W., and Wang. L.:
Jointly learn-
ing semantic parser and natural language genera-
tor via dual information maximization. in Proceed-
Vol. 40
No. 2
May 2023
127
ings of the 57th Annual Meeting of the Associa-
tion for Computational Linguistics, Florence, Italy,
July 2019, Association for Computational Linguis-
tics, pp. 2090–2101.
[143]
Yin, P. and Neubig, G.:
A syntactic neural
model for general-purpose code generation. in Pro-
ceedings of the 55th Annual Meeting of the Asso-
ciation for Computational Linguistics (Volume 1:
Long Papers), Vancouver, Canada, July 2017, Asso-
ciation for Computational Linguistics, pp. 440–450.
[144]
Yin, P. and Neubig, G.: Reranking for neural
semantic parsing. in Proceedings of the 57th Annual
Meeting of the Association for Computational Lin-
guistics, Florence, Italy, July 2019. Association for
Computational Linguistics, pp. 4553–4559.
[145]
Young, H., Bastani, O., and Naik, M.: Learn-
ing neurosymbolic generative models via program
synthesis. in Chaudhuri, K. and Salakhutdinov, R.
editors, Proceedings of the 36th International Con-
ference on Machine Learning, Volume 97 of Pro-
ceedings of Machine Learning Research, PMLR, 09–
15 Jun 2019, pp. 7144–7153.
[146]
Zhang, L., Rosenblatt, G., Fetaya, E., Liao,
R., Byrd, W., Might, M., Urtasun, R., and Zemel,
R.:
Neural guided constraint logic programming
for program synthesis. in Bengio, S., Wallach, H.,
Larochelle, H., Grauman, K., Cesa-Bianchi, N., and
Garnett, R. editors, Advances in Neural Informa-
tion Processing Systems, Volume 31, Curran Asso-
ciates, Inc., 2018.
[147]
Zhong, R., Stern, M., and Klein, D.:
Se-
mantic scaﬀolds for pseudocode-to-code generation.
in Proceedings of the 58th Annual Meeting of the
Association for Computational Linguistics, Online,
July 2020. Association for Computational Linguis-
tics, pp. 2283–2295.
[148]
Zhu, H., Xiong, Z., Magill, S., and Jagan-
nathan, S.:
An inductive synthesis framework for
veriﬁable reinforcement learning. in Proceedings of
the 40th ACM SIGPLAN Conference on Program-
ming Language Design and Implementation, PLDI
2019, New York, NY, USA, 2019, Association for
Computing Machinery, pp. 686–701.
[149]
Zohar, A. and Wolf, L.:
Automatic program
synthesis of long programs with a learned garbage
collector. in Proceedings of the 32nd International
Conference on Neural Information Processing Sys-
tems, NIPS’18, Red Hook, NY, USA, 2018, Curran
Associates Inc, pp. 2098–2107.
倉林利行
2012 年慶應大学理工学部システムデ
ザイン工学科卒業．2014 年同大学大
学院理工学研究科総合デザイン専攻
博士前期課程修了．同年日本電信電
話(株) 入社．2016 年度コンピュータサイエンス領域
奨励賞(情報処理学会)．2020 年度SES 最優秀論文
賞(情報処理学会SE 研究会)．2020 年度SES Young
Researcher Award(IEEE)．主にプログラム合成，ソ
フトウェアテストに関する研究開発に従事．
丹野治門
2007 年電気通信大学電気通信学部
情報工学科卒業．2009 年同大学大学
院電気通信学研究科情報工学専攻博
士前期課程修了．同年日本電信電話
(株) 入社．2020 年電気通信大学大学院情報理工学研
究科情報・ネットワーク工学専攻博士後期課程修了．
2008 年未踏ユース・スーパークリエータ認定(情報
処理推進機構)，2009 年山内奨励賞(情報処理学会)，
2013 年山下記念研究賞(情報処理学会)，2016 年企業
賞(情報処理学会)，2016 年社長表彰(日本電信電話)，
2018 年優秀発表賞，学生奨励賞(日本ソフトウェア科
学会)，2020 年企業・ポスター賞(情報処理学会) ソフ
トウェアテスト，デバッグに関する研究開発に従事．
切貫弘之
2015 年大阪大学大学院情報科学研
究科コンピュータサイエンス専攻博
士前期課程修了．同年日本電信電話
(株) 入社．2015 年度コンピュータサ
イエンス領域奨励賞(情報処理学会)．2018 年度山下
記念研究賞(情報処理学会)．主にリポジトリマイニ
ング，ソースコード解析，ソフトウェアテストに関す
る研究開発に従事．
128
コンピュータソフトウェア
大島剛志
2010 年北海道大学大学院工学研究科
応用物理学専攻修士課程修了．同年
日本電信電話(株) 入社．ソフトウェ
ア開発技術に関する研究開発に従事．
